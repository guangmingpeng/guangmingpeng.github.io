<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2020/08/08/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2020/08/08/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><p>因为前段时间在公司项目中一个场景下需要用到观察者模式，所以在此做一个记录。</p><p>我遇到的问题是，在一个参数设置页面设置参数后，需要其它依赖这个参数的对象同时更新这些参数，如果采用后者不断去轮询的方式，一来消耗性能，二来也不能保证得到及时的更新，所以考虑使用观察者模式。</p><p>观察者模式(<em>Observer Pattern</em>)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。<br>观察者模式是一种对象行为型模式。<br>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式中有“观察者” 和 “被观察者”，举个例子，微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是<em>被观察者<em>，而用户就是</em>观察者</em></p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><p><img src="img/1.jpg" alt="1"><br><img src="img/2.jpg" alt="2"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="Subject（目标）"><a href="#Subject（目标）" class="headerlink" title="Subject（目标）"></a>Subject（目标）</h4><p>被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p><h4 id="ConcreteSubject（具体目标）："><a href="#ConcreteSubject（具体目标）：" class="headerlink" title="ConcreteSubject（具体目标）："></a>ConcreteSubject（具体目标）：</h4><p>具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><h4 id="Observer（观察者）："><a href="#Observer（观察者）：" class="headerlink" title="Observer（观察者）："></a>Observer（观察者）：</h4><p>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。<br>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update()方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>定义观察者接口</li></ol><pre><code>    interface Observer {        public void update();`    }</code></pre><ol start="2"><li>定义被观察者</li></ol><pre><code>abstract class Subject {    private Vector&lt;Observer&gt; obs = new Vector();    public void addObserver(Observer obs){        this.obs.add(obs);    }    public void delObserver(Observer obs){        this.obs.remove(obs);    }    protected void notifyObserver(){        for(Observer o: obs){            o.update();        }    }    public abstract void doSomething();}</code></pre><ol start="3"><li><p>具体的被观察者</p><pre><code>class ConcreteSubject extends Subject { public void doSomething(){     System.out.println("被观察者事件发生改变");     this.notifyObserver(); }}</code></pre></li><li><p>具体的被观察者</p><pre><code>class ConcreteObserver1 implements Observer { public void update() {     System.out.println("观察者1收到信息，并进行处理"); }}class ConcreteObserver2 implements Observer { public void update() {     System.out.println("观察者2收到信息，并进行处理"); }}</code></pre></li><li><p>客户端</p><pre><code>public class Client { public static void main(String[] args){     Subject sub = new ConcreteSubject();     sub.addObserver(new ConcreteObserver1()); //添加观察者1     sub.addObserver(new ConcreteObserver2()); //添加观察者2     sub.doSomething(); }}</code></pre><p>输出</p><pre><code>被观察者事件发生改变</code></pre></li></ol><p>观察者1收到信息，并进行处理</p><p>观察者2收到信息，并进行处理复制代码</p><pre><code>通过运行结果可以看到，我们只调用了 Subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 Subject 类中关联一下 Observer 类，并且在 doSomething() 方法中遍历一下 Observer 的 update() 方法就行了。#### 优缺点**优点**降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系目标与观察者之间建立了一套触发机制支持广播通信符合“开闭原则”的要求**缺点**目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率**应用**JDK中的观察者模式观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持（可以去查看下源码，写的比较严谨）。but，在 Java9 被弃用了。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Activity</title>
      <link href="/2020/07/16/qian-tan-activity/"/>
      <url>/2020/07/16/qian-tan-activity/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Activity"><a href="#什么是Activity" class="headerlink" title="什么是Activity"></a>什么是Activity</h2><ol><li>Activity一直是一个老生长谈的问题，大概是因为用的多，所以谈论的自然也多一些。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开门第一话</title>
      <link href="/2020/05/17/kai-men-di-yi-hua/"/>
      <url>/2020/05/17/kai-men-di-yi-hua/</url>
      
        <content type="html"><![CDATA[<p>有自己的空间是件有意思的事情。</p><p>做好这个小房子前，其实并没有想好要往里边放什么，这是很奇怪的。木匠做好一个柜子前，他应该先想好这是个衣柜还是鞋柜。然而现在先把柜子做好了，我需要停下来，考虑拿它来干什么用。这又引出了另外一个问题，我能做什么？得先知道自己能做出什么事情，才能知道有什么事情交给别人做，毫无疑问，知道自己究竟能做什么是件很难的事情，但我大致想好了。</p><p>其一是日常所学。闻道有先后，我并不介意自己分享十分基础的知识，我其实能想象得到，每过一段时间回头再看，都会发现自己以前的愚蠢与浅薄。但假如真的能做到这样，说明我还是有所进步的，否认以前的自己并不完全是件坏事。</p><p>身上的烟火气息提醒我，平日里的柴米油盐，嬉笑怒骂同样珍贵，或许哪天上的是一则游记，或许是一个菜谱，或许是一个笑话，或奇闻，或五行八卦阴阳异术……还是回到之前的问题：我到底会什么？</p><pre><code>“you know nothing”---- Ygritte</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
