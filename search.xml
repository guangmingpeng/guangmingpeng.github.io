<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之建造者模式</title>
      <link href="/2020/08/09/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/"/>
      <url>/2020/08/09/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之建造者模式"><a href="#设计模式之建造者模式" class="headerlink" title="设计模式之建造者模式"></a>设计模式之建造者模式</h1><p>在java中实例化某个类的对象时，我们会经常碰到 <em>**bulider</em> 这样的形式，这其实是使用的就是建造者模式。但是为什么不直接用普通的方法去实例化，而要这么绕一下呢？这种情况我觉得在设计模式中经常遇到，比如工厂模式也是如此，代理模式也是如此，总的来说，这样的看似“多余”的做法，其实是在设计原则的指导下而形成的。一般来说，当一个类的构造函数参数个数较多，而且这些参数有些是可选的参数，就可以考虑使用建造者模式。</p><p>我们先从一个例子说起。</p><p>例如我们现在有如下一个类计算机类Computer，其中cpu与ram是必填参数，而其他3个是可选参数，那么我们如何构造这个类的实例呢,通常有两种常用的方式：</p><pre><code>public class Computer {    private String cpu;//必须    private String ram;//必须    private int usbCount;//可选    private String keyboard;//可选    private String display;//可选}</code></pre><p>第一：折叠构造函数模式（telescoping constructor pattern ），这个我们经常用,如下代码所示</p><pre><code>public class Computer {     ...    public Computer(String cpu, String ram) {        this(cpu, ram, 0);    }    public Computer(String cpu, String ram, int usbCount) {        this(cpu, ram, usbCount, "罗技键盘");    }    public Computer(String cpu, String ram, int usbCount, String keyboard) {        this(cpu, ram, usbCount, keyboard, "三星显示器");    }    public Computer(String cpu, String ram, int usbCount, String keyboard, String display) {        this.cpu = cpu;        this.ram = ram;        this.usbCount = usbCount;        this.keyboard = keyboard;        this.display = display;    }}</code></pre><p>第二种：Javabean 模式，如下所示</p><pre><code>public class Computer {        ...    public String getCpu() {        return cpu;    }    public void setCpu(String cpu) {        this.cpu = cpu;    }    public String getRam() {        return ram;    }    public void setRam(String ram) {        this.ram = ram;    }    public int getUsbCount() {        return usbCount;    }...}</code></pre><p>那么这两种方式有什么弊端呢？ 第一种主要是使用及阅读不方便。你可以想象一下，当你要调用一个类的构造函数时，你首先要决定使用哪一个，然后里面又是一堆参数，如果这些参数的类型很多又都一样，你还要搞清楚这些参数的含义，很容易就传混了。。。那酸爽谁用谁知道。 第二种方式在构建过程中对象的状态容易发生变化，造成错误。因为那个类中的属性是分步设置的，所以就容易出错。<br>为了解决这两个痛点，builder模式就横空出世了。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><ul><li><p>在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。</p></li><li><p>在Computer中创建一个private的构造函数，参数为Builder类型</p></li><li><p>在Builder中创建一个public的构造函数，参数为Computer中必填的那些参数，cpu 和ram。</p></li><li><p>在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例</p></li><li><p>在Builder中创建一个build()方法，在其中构建Computer的实例并返回<br>下面代码就是最终的样子</p><pre><code>public class Computer {  private final String cpu;//必须  private final String ram;//必须  private final int usbCount;//可选  private final String keyboard;//可选  private final String display;//可选  private Computer(Builder builder){      this.cpu=builder.cpu;      this.ram=builder.ram;      this.usbCount=builder.usbCount;      this.keyboard=builder.keyboard;      this.display=builder.display;  }  public static class Builder{      private String cpu;//必须      private String ram;//必须      private int usbCount;//可选      private String keyboard;//可选      private String display;//可选      public Builder(String cup,String ram){          this.cpu=cup;          this.ram=ram;      }      public Builder setUsbCount(int usbCount) {          this.usbCount = usbCount;          return this;      }      public Builder setKeyboard(String keyboard) {          this.keyboard = keyboard;          return this;      }      public Builder setDisplay(String display) {          this.display = display;          return this;      }              public Computer build(){          return new Computer(this);      }  }}</code></pre></li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在客户端使用链式调用，一步一步的把对象构建出来。</p><pre><code>Computer computer=new Computer.Builder("因特尔","三星")                .setDisplay("三星24寸")                .setKeyboard("罗技")                .setUsbCount(2)                .build();</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>构建者模式是一个非常实用而常见的创建类型的模式（creational design pattern)，例如图片处理框架Glide，网络请求框架Retrofit等都使用了此模式。</p><p><strong>扩展</strong></p><p>其实上面的内容是Builder在Java中一种简化的使用方式，经典的Builder 模式与其有一定的不同，如果没有兴趣的同学就可以不用往下读了。</p><h3 id="建造者模式-VS-简单工厂模式"><a href="#建造者模式-VS-简单工厂模式" class="headerlink" title="建造者模式 VS 简单工厂模式"></a>建造者模式 VS 简单工厂模式</h3><p><strong>相似点</strong></p><p>它们都属于创建型模式「都是创建产品的」</p><p><strong>区别</strong></p><ol><li>创建对象的粒度不同<br>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</li><li>关注点不同：<br>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</li></ol><h3 id="补充：-静态内部类和非静态内部类区别"><a href="#补充：-静态内部类和非静态内部类区别" class="headerlink" title="补充： 静态内部类和非静态内部类区别"></a>补充： 静态内部类和非静态内部类区别</h3><p><strong>总结</strong></p><ol><li><p>是否能拥有静态成员<br>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)</p></li><li><p>访问外部类的成员<br>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</p></li><li><p>静态内部类和非静态内部类在创建时有区别<br>//假设类A有静态内部类B和非静态内部类C，创建B和C的区别为：</p><pre><code>A a=new A(); A.B b=new A.B(); A.C c=a.new C();</code></pre></li></ol><p><strong>在建造者模式中使用静态内部类的原因:</strong></p><p>静态内部类相当于是一个独立的类，但是如果某个类A只想被类B使用，则可以把A作为静态内部类放到B中，这样就能B.A.method()这样去使用了，相当于在A的前面加了一个限定符，避免A放在外面时，被其他类所依赖。同时，在外部类没有初始化时，同样可以初始化静态内部类，如上面的做法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2020/08/08/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2020/08/08/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><p>因为前段时间在公司项目中一个场景下需要用到观察者模式，所以在此做一个记录。</p><p>我遇到的问题是，在一个参数设置页面设置参数后，需要其它依赖这个参数的对象同时更新这些参数，如果采用后者不断去轮询的方式，一来消耗性能，二来也不能保证得到及时的更新，所以考虑使用观察者模式。</p><p>观察者模式(<em>Observer Pattern</em>)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。<br>观察者模式是一种对象行为型模式。<br>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式中有“观察者” 和 “被观察者”，举个例子，微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是<em>被观察者<em>，而用户就是</em>观察者</em></p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><p><img src="https://ae03.alicdn.com/kf/U1cffe803ca594bc7891c087dbcb28682c.png" alt="1"><br><img src="https://ae04.alicdn.com/kf/Udb3f3bbee22d4e5096b87aafaffdb4cfX.png" alt="2"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="Subject（目标）"><a href="#Subject（目标）" class="headerlink" title="Subject（目标）"></a>Subject（目标）</h4><p>被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p><h4 id="ConcreteSubject（具体目标）："><a href="#ConcreteSubject（具体目标）：" class="headerlink" title="ConcreteSubject（具体目标）："></a>ConcreteSubject（具体目标）：</h4><p>具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><h4 id="Observer（观察者）："><a href="#Observer（观察者）：" class="headerlink" title="Observer（观察者）："></a>Observer（观察者）：</h4><p>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。<br>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update()方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>定义观察者接口</li></ol><pre><code>    interface Observer {        public void update();`    }</code></pre><ol start="2"><li>定义被观察者</li></ol><pre><code>abstract class Subject {    private Vector&lt;Observer&gt; obs = new Vector();    public void addObserver(Observer obs){        this.obs.add(obs);    }    public void delObserver(Observer obs){        this.obs.remove(obs);    }    protected void notifyObserver(){        for(Observer o: obs){            o.update();        }    }    public abstract void doSomething();}</code></pre><ol start="3"><li><p>具体的被观察者</p><pre><code>class ConcreteSubject extends Subject { public void doSomething(){     System.out.println("被观察者事件发生改变");     this.notifyObserver(); }}</code></pre></li><li><p>具体的被观察者</p><pre><code>class ConcreteObserver1 implements Observer { public void update() {     System.out.println("观察者1收到信息，并进行处理"); }}class ConcreteObserver2 implements Observer { public void update() {     System.out.println("观察者2收到信息，并进行处理"); }}</code></pre></li><li><p>客户端</p><pre><code>public class Client { public static void main(String[] args){     Subject sub = new ConcreteSubject();     sub.addObserver(new ConcreteObserver1()); //添加观察者1     sub.addObserver(new ConcreteObserver2()); //添加观察者2     sub.doSomething(); }}</code></pre></li></ol><p>输出</p><p><em>被观察者事件发生改变</em></p><p><em>观察者1收到信息，并进行处理</em></p><p><em>观察者2收到信息，并进行处理复制代码</em></p><p>通过运行结果可以看到，我们只调用了 Subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 Subject 类中关联一下 Observer 类，并且在 doSomething() 方法中遍历一下 Observer 的 update() 方法就行了。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系<br>目标与观察者之间建立了一套触发机制<br>支持广播通信<br>符合“开闭原则”的要求</p><p><strong>缺点</strong></p><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用<br>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</p><p><strong>应用</strong></p><p>JDK中的观察者模式<br>观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持（可以去查看下源码，写的比较严谨）。but，在 Java9 被弃用了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Activity</title>
      <link href="/2020/07/16/qian-tan-activity/"/>
      <url>/2020/07/16/qian-tan-activity/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Activity"><a href="#什么是Activity" class="headerlink" title="什么是Activity"></a>什么是Activity</h2><ol><li>Activity一直是一个老生长谈的问题，大概是因为用的多，所以谈论的自然也多一些。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开门第一话</title>
      <link href="/2020/05/17/kai-men-di-yi-hua/"/>
      <url>/2020/05/17/kai-men-di-yi-hua/</url>
      
        <content type="html"><![CDATA[<p>有自己的空间是件有意思的事情。</p><p>做好这个小房子前，其实并没有想好要往里边放什么，这是很奇怪的。木匠做好一个柜子前，他应该先想好这是个衣柜还是鞋柜。然而现在先把柜子做好了，我需要停下来，考虑拿它来干什么用。这又引出了另外一个问题，我能做什么？得先知道自己能做出什么事情，才能知道有什么事情交给别人做，毫无疑问，知道自己究竟能做什么是件很难的事情，但我大致想好了。</p><p>其一是日常所学。闻道有先后，我并不介意自己分享十分基础的知识，我其实能想象得到，每过一段时间回头再看，都会发现自己以前的愚蠢与浅薄。但假如真的能做到这样，说明我还是有所进步的，否认以前的自己并不完全是件坏事。</p><p>身上的烟火气息提醒我，平日里的柴米油盐，嬉笑怒骂同样珍贵，或许哪天上的是一则游记，或许是一个菜谱，或许是一个笑话，或奇闻，或五行八卦阴阳异术……还是回到之前的问题：我到底会什么？</p><pre><code>“you know nothing”---- Ygritte</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
