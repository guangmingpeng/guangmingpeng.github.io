<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之建造者模式</title>
      <link href="/2020/07/01/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/"/>
      <url>/2020/07/01/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之建造者模式"><a href="#设计模式之建造者模式" class="headerlink" title="设计模式之建造者模式"></a>设计模式之建造者模式</h1><p>在java中实例化某个类的对象时，我们会经常碰到 <em>**bulider</em> 这样的形式，这其实是使用的就是建造者模式。但是为什么不直接用普通的方法去实例化，而要这么绕一下呢？这种情况我觉得在设计模式中经常遇到，比如工厂模式也是如此，代理模式也是如此，总的来说，这样的看似“多余”的做法，其实是在设计原则的指导下而形成的。一般来说，当一个类的构造函数参数个数较多，而且这些参数有些是可选的参数，就可以考虑使用建造者模式。</p><p>我们先从一个例子说起。</p><p>例如我们现在有如下一个类计算机类Computer，其中cpu与ram是必填参数，而其他3个是可选参数，那么我们如何构造这个类的实例呢,通常有两种常用的方式：</p><pre><code>public class Computer {    private String cpu;//必须    private String ram;//必须    private int usbCount;//可选    private String keyboard;//可选    private String display;//可选}</code></pre><p>第一：折叠构造函数模式（telescoping constructor pattern ），这个我们经常用,如下代码所示</p><pre><code>public class Computer {     ...    public Computer(String cpu, String ram) {        this(cpu, ram, 0);    }    public Computer(String cpu, String ram, int usbCount) {        this(cpu, ram, usbCount, "罗技键盘");    }    public Computer(String cpu, String ram, int usbCount, String keyboard) {        this(cpu, ram, usbCount, keyboard, "三星显示器");    }    public Computer(String cpu, String ram, int usbCount, String keyboard, String display) {        this.cpu = cpu;        this.ram = ram;        this.usbCount = usbCount;        this.keyboard = keyboard;        this.display = display;    }}</code></pre><p>第二种：Javabean 模式，如下所示</p><pre><code>public class Computer {        ...    public String getCpu() {        return cpu;    }    public void setCpu(String cpu) {        this.cpu = cpu;    }    public String getRam() {        return ram;    }    public void setRam(String ram) {        this.ram = ram;    }    public int getUsbCount() {        return usbCount;    }...}</code></pre><p>那么这两种方式有什么弊端呢？ 第一种主要是使用及阅读不方便。你可以想象一下，当你要调用一个类的构造函数时，你首先要决定使用哪一个，然后里面又是一堆参数，如果这些参数的类型很多又都一样，你还要搞清楚这些参数的含义，很容易就传混了。。。那酸爽谁用谁知道。 第二种方式在构建过程中对象的状态容易发生变化，造成错误。因为那个类中的属性是分步设置的，所以就容易出错。<br>为了解决这两个痛点，builder模式就横空出世了。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><ul><li><p>在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。</p></li><li><p>在Computer中创建一个private的构造函数，参数为Builder类型</p></li><li><p>在Builder中创建一个public的构造函数，参数为Computer中必填的那些参数，cpu 和ram。</p></li><li><p>在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例</p></li><li><p>在Builder中创建一个build()方法，在其中构建Computer的实例并返回<br>下面代码就是最终的样子</p><pre><code>public class Computer {  private final String cpu;//必须  private final String ram;//必须  private final int usbCount;//可选  private final String keyboard;//可选  private final String display;//可选  private Computer(Builder builder){      this.cpu=builder.cpu;      this.ram=builder.ram;      this.usbCount=builder.usbCount;      this.keyboard=builder.keyboard;      this.display=builder.display;  }  public static class Builder{      private String cpu;//必须      private String ram;//必须      private int usbCount;//可选      private String keyboard;//可选      private String display;//可选      public Builder(String cup,String ram){          this.cpu=cup;          this.ram=ram;      }      public Builder setUsbCount(int usbCount) {          this.usbCount = usbCount;          return this;      }      public Builder setKeyboard(String keyboard) {          this.keyboard = keyboard;          return this;      }      public Builder setDisplay(String display) {          this.display = display;          return this;      }              public Computer build(){          return new Computer(this);      }  }}</code></pre></li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在客户端使用链式调用，一步一步的把对象构建出来。</p><pre><code>Computer computer=new Computer.Builder("因特尔","三星")                .setDisplay("三星24寸")                .setKeyboard("罗技")                .setUsbCount(2)                .build();</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>构建者模式是一个非常实用而常见的创建类型的模式（creational design pattern)，例如图片处理框架Glide，网络请求框架Retrofit等都使用了此模式。</p><p>在我使用的过程中，是设置蓝牙过滤器时使用到ScanFilter这个类：</p><pre><code>ScanFilter filter = new ScanFilter.Builder().setDeviceAddress(address).build();</code></pre><p>在ScanFilter中，具体的定义方式与上面给出的不太一样，这里节选其中的部分代码：</p><pre><code>public final class ScanFilter implements Parcelable {    @Nullable    private final String mDeviceName;    @Nullable    private final String mDeviceAddress;    @Nullable    private final ParcelUuid mServiceUuid;    @Nullable    private final ParcelUuid mServiceUuidMask;    ....    ....    @Nullable    private final byte[] mManufacturerDataMask;    /** @hide */    public static final ScanFilter EMPTY = new ScanFilter.Builder().build();    private ScanFilter(String name, String deviceAddress, ParcelUuid uuid,            ParcelUuid uuidMask, ParcelUuid solicitationUuid,            ParcelUuid solicitationUuidMask, ParcelUuid serviceDataUuid,            byte[] serviceData, byte[] serviceDataMask,            int manufacturerId, byte[] manufacturerData, byte[] manufacturerDataMask) {        mDeviceName = name;        mServiceUuid = uuid;        mServiceUuidMask = uuidMask;        ....        ....        mManufacturerData = manufacturerData;        mManufacturerDataMask = manufacturerDataMask;    }public static final class Builder {        private String mDeviceName;        private String mDeviceAddress;        private ParcelUuid mServiceUuid;        private ParcelUuid mUuidMask;        ....        ....        ....        private byte[] mManufacturerDataMask;        public Builder setDeviceName(String deviceName) {            mDeviceName = deviceName;            return this;        }        public Builder setDeviceAddress(String deviceAddress) {            if (deviceAddress != null &amp;&amp; !BluetoothAdapter.checkBluetoothAddress(deviceAddress)) {                throw new IllegalArgumentException("invalid device address " + deviceAddress);            }            mDeviceAddress = deviceAddress;            return this;        }     public ScanFilter build() {            return new ScanFilter(mDeviceName, mDeviceAddress,                    mServiceUuid, mUuidMask, mServiceSolicitationUuid,                    ....                    ....                    mManufacturerId, mManufacturerData, mManufacturerDataMask);        }    }</code></pre><p>在ScanFilter的构造函数中，不是传入的Builder对象，而是直接将设置后的参数传入ScanFilter中，不过这与前面的例子本质是一致的，都是通过build()方法去调用外部类的构造方法。<br><strong>扩展</strong></p><p>其实上面的内容是Builder在Java中一种简化的使用方式，经典的Builder 模式与其有一定的不同，如果没有兴趣的同学就可以不用往下读了。</p><h3 id="建造者模式-VS-简单工厂模式"><a href="#建造者模式-VS-简单工厂模式" class="headerlink" title="建造者模式 VS 简单工厂模式"></a>建造者模式 VS 简单工厂模式</h3><p><strong>相似点</strong></p><p>它们都属于创建型模式「都是创建产品的」</p><p><strong>区别</strong></p><ol><li>创建对象的粒度不同<br>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</li><li>关注点不同：<br>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</li></ol><h3 id="补充：-静态内部类和非静态内部类区别"><a href="#补充：-静态内部类和非静态内部类区别" class="headerlink" title="补充： 静态内部类和非静态内部类区别"></a>补充： 静态内部类和非静态内部类区别</h3><p><strong>总结</strong></p><ol><li><p>是否能拥有静态成员<br>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)</p></li><li><p>访问外部类的成员<br>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</p></li><li><p>静态内部类和非静态内部类在创建时有区别<br>//假设类A有静态内部类B和非静态内部类C，创建B和C的区别为：</p><pre><code>A a=new A(); A.B b=new A.B(); A.C c=a.new C();</code></pre></li></ol><p><strong>在建造者模式中使用静态内部类的原因:</strong></p><p>静态内部类相当于是一个独立的类，但是如果某个类A只想被类B使用，则可以把A作为静态内部类放到B中，这样就能B.A.method()这样去使用了，相当于在A的前面加了一个限定符，避免A放在外面时，被其他类所依赖。同时，在外部类没有初始化时，同样可以初始化静态内部类，如上面的做法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷老师STL-听课笔记</title>
      <link href="/2020/07/01/hou-jie-lao-shi-stl-ting-ke-bi-ji/"/>
      <url>/2020/07/01/hou-jie-lao-shi-stl-ting-ke-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="侯捷老师STL-听课笔记"><a href="#侯捷老师STL-听课笔记" class="headerlink" title="侯捷老师STL-听课笔记"></a>侯捷老师STL-听课笔记</h1><p>1.binary_search使用时必须为有序容器</p><p>2.find算法使用时，如果没有查到目标元素，返回值的迭代器是b.end()，因为它是从头逐个开始查找的，所以如果没有目标值，就会一直走到容器尾部。</p><p>3.如果使用的算法涉及自定义类型对象的比较或者查找，需要在自定义类中重载＝＝号。如果参数是需要传入的是仿函数，则定义一个仿函数重载()，注意区分这两种情况，主要是要看算法的参数类型。</p><p>4.random_shuffle默认每次打乱后的结果是一样的，如果要实现每次打乱的结果不一样，则需要设置随机种子，导入<ctime>，srand（（unsigned int）time（NULL））。</ctime></p><p>5.Set_union,set_intersection,set_difference(差集)所传入的容器需要是有序的，并且返回值需要一个迭代器接受，这个迭代器指向输出结果的尾部。对于输出结果的存放，先要定义一个空间足够的容器，容器的起始地址作为参数。</p><p>6.构造函数与析构函数都是不继承的，子类中会重新生成默认的构造函数，在继承时，子类的构造函数的调用顺叙为，如果继承多个类，1 按照继承顺叙从左到右的顺叙依次调用父类的构造函数；2 类成员变量中有继承自父类的，按顺叙调用父类的构造函数（继承自父类的成员变量要调用父类的构造函数进行初始化）；3 调用本类自己的构造函数</p><p>7.为什么list容器不能像vector，deque那样使用algorithm的sort算法？？（9）</p><p>源码： 是因为list底层是用链表实现的，他的指针（迭代器）不能支持随机访问，而algorithm库里的sort函数需要下图红字的操作</p><p><img src="https://pic.rmb.bdstatic.com/bjh/a8297ea85a77919d3923e1a8f874c396.png" alt="图片1.png"></p><p>8.Deque在需要扩容时是如何实现的？与vector有何不同（两倍扩容）？</p><p>Deque是在内存上是分段连续的，扩容的时候是首位位置增加一个新的连续片段</p><p>9.分配器的实现，需要的参数（p是指针，1是分配的空间个数）</p><p><img src="https://ae01.alicdn.com/kf/Hb808568ca9f74351bc83dd8e6f41cddfU.png" alt="image.png"></p><p>10.Oop面向对象是为了实现数据和方法的组合，而泛型编程则是把数据和方法实现分离。</p><p>11.泛化，特化，偏特化。<br>泛化可以适用于不同的类型，但是可能对于某些特定的类型，函数要用不同的实现方式，这个时候可以对特定类型，模板可以做特化（明确原来模板的所有类型），偏特化则是明确部分类型。注意三者之间语法的不同。<br><img src="https://pic.rmb.bdstatic.com/bjh/812bec8d9d08567218eb33eb8c103ecc.png" alt="image.png"><br>源码中的特化例子</p><p><img src="https://ae03.alicdn.com/kf/H84a67b478db449cfa18a201a1edaf7c7W.png" alt="image.png"></p><p>偏特化例子</p><p><img src="https://ae04.alicdn.com/kf/H0e9d5db71c894eb7abde90ffd8368de7B.png" alt="image.png"></p><p>12.分配器 allocators</p><p>分配器其实在容器声明的时候可以指明，但一般没有必要，不声明的时候编译器会调用默认的。通过allocator对象调用Allocate 和 deallocate函数，而这两个函数是通过new函数和delete函数实现的，而new，delete函数都是通过调用malloc，free函数实现的。但是malloc函数在分配内存时，除了所用于存储数据的部分外，还有overhead部分，用来存储该内存块的信息，这部分也是会占不少空间的。所以当malloc较小内存的时候，该部分就会占较大的比例。<br><img src="https://pic.rmb.bdstatic.com/bjh/8ac022481ef4030ac59fc4214a6c31cb.png" alt="image.png"><br><img src="https://pic.rmb.bdstatic.com/bjh/0497efe8587c4a3107a44da814cec6a1.png" alt="image.png"></p><p><img src="https://ae03.alicdn.com/kf/Hb075b4074f9d45d08a6339cb9e889d120.png" alt="image.png"></p><p>13.容器的结构与分类</p><p><img src="https://ae02.alicdn.com/kf/Hadb8549876d8474a8ab9c463744170c6h.png" alt="image.png"><br><img src="https://ae01.alicdn.com/kf/Hae6104aabdf9403b8c35a170acb23dadL.png" alt="image.png"></p><p>14.深入理解list</p><p>List是用双向循环链表实现的，为了表示出容器的左开右闭的特性，end（）迭代器指向的尾部是一个空节点。每种容器都有自己的iterator实现，它们的iterator都会自己typedef五个类型，并且重载<em>，-&gt;，++（前），（后）++等操作符。比如list的</em>号重载是要返回当前节点的data，而前++与后++的重载也要注意，由于是链表，所以++操作的时候是返回下一个节点的指针，而不是像连续区间那样直接往后移动一个单位。<br>另外，对于++操作，前++是可以连续操作的，比如++（++i），所以返回值需要是原来对象的引用，而i++++是不被允许的，所以返回值就不能是该对象的引用。另外，重载++符号的时候，由于无法区分前++和后++，所以重载前++的时候，在添加一个“int”作为占位参数来区分。见下图的红色圈出部分。每个节点的前后指针都要占4或者8个字节，这在使用容器的时候要有意识。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/df36cb11be4134c94d43b04575861756.png" alt="image.png"><br><img src="https://ae04.alicdn.com/kf/H3b639cc3f7e34fdca7278963e0662a09q.png" alt="image.png"><br><img src="https://ae02.alicdn.com/kf/H6e74cfbd68d946b4855fef06a9c42ded1.png" alt="image.png"></p><p>15.Iterator作为容器与算法之间连接的桥梁，定义在每一种容器的内部，指针可以看作是一种退化的迭代器。因为数据与算法分离，算法需要知道容器的数据类型，迭代器类型，以及步长限制（迭代器能+1还是可以+任意值），这些都要通过迭代器获取。但是传给算法的迭代器有可能是退化的iterator，也就是指针，而指针是不能提供上述信息的，所以需要一个trait（特征的意思），萃取器，把是指针的迭代器过滤掉。<br><img src="https://ae03.alicdn.com/kf/Hc9a219c11201412aa3700ff289e093dfc.png" alt="image.png"><br><img src="https://pic.rmb.bdstatic.com/bjh/6b02e5a7fcab870edad749f7faeb3976.png" alt="image.png"></p><p>10 vector详解</p><p>Vector可以看作是一个可扩充的数组，每次扩容是按两倍扩容，如果原来的空间是0的话，第一次扩容则是变为1，没有扩容是在原来空间上进行的，都需要另行开辟空间。vector中维护三个指针，start，finish，end_of_storage.如图，所以对一个vertor求sizeof的时候，大小应该是12.（注意不是说size（））。三个指针也用来计算实现capacity，size函数，注意对于连续存储的容器（包括deque），都是可以用中括号[ ]来随机访问的，比如下图中就有[ ]的重载。<br><img src="https://pic.rmb.bdstatic.com/bjh/7b1d92da84d70585281e7f75ebb63d13.png" alt="image.png"><br>16.Array 详解<br>Array是一个定长的数组，所以在定义一个array的时候需要指定数组长度，如果指定是0的话，源码中也会对此做判断，然后初始化的时候给出1个单位空间，见下图红色横线部分。Array的iterator是一个普通的指针，所以萃取器使用的也是上面那一部分。另外，array是没有构造函数和析构函数的，可以注意到它是一个struct。</p><p><img src="https://ae01.alicdn.com/kf/H26c16d554b064d4b98124404edf568dbs.png" alt="image.png"></p><p>17.Deque详解<br>Deque是分段连续的，分段是本质，连续是表象。它有一个控制中心，就是图中的map所示的部分，是用一个vector实现的，应为要实现动态的增加buffer段，需要用到vertor的扩容的特性。Vector中存储的是指针，指向各个不同的分段。而iterator中则存储了四个指针，分别指向数据段的当前数据，开始位置，结束位置和node，它指向所在段在vector中所对应的位置。当在查找段中的数据时，他会检测是否到了所在段的边缘，若已超过所在段的范围，则开始移动到vector中的下一个指针，到达下一个buffer，通过这样的方法实现模拟出了连续空间。扩容的时候，先开辟一个buffer的空间，然后在vector中新增一个指针，指向这个新增的buffer，从而实现双端扩容。从这里可以看出iterator是一中功能更加强大的指针。<br>所以可以说deque的连续性主要是通过它的iterator实现的。<br>当它扩容的时候，vector是两倍扩容的，为了方便deque的双端操作，所以在vertor进行原来的内容拷贝的时候，会把内容拷贝到新vector的中间位置，以便deque的双端扩容。<br>Deque的insert函数的实现，非常智能。如果是插入在首位位置，则直接调用push_back()或者push_front()函数，如果插入在中间，则先计算插入位置离头近还是离尾近，然后选择一个更近的方向，把元素往前移动，然后再插入相应位置。<br><img src="https://ae01.alicdn.com/kf/Hed2a99abc7da4929b3bf6d0d6b438b9da.png" alt="image.png"><br><img src="https://ae02.alicdn.com/kf/H2bb7b1b5854e4fa68845765ec1d483f3q.png" alt="image.png"><br><img src="https://ae03.alicdn.com/kf/H98b237def20748da85597825e6d66daf1.png" alt="image.png"></p><p>18.Stack，queue详解</p><p>Stack和queue默认底层都是通过deque实现的，因为deque完全可以满足它们所需要的功能。这两种容器都不能遍历，也没有迭代器。Stack的pop函数就通过调用deque的pop_back()函数。queue的相应函数也是通过调用deque的函数实现的。<br>所以相应的，其实stack和queue也可以用list作为它的底层。<br>Stack可以用vector作为他的底层，但是queue不可以，原因时vector无法提供pop_front函数。同理，这两种容器也不能使用map或者set作为他的底层。</p><p><img src="https://ae01.alicdn.com/kf/H669e55b578004ce49c626dbd08087c07D.png" alt="image.png"><br><img src="https://ae01.alicdn.com/kf/H3d6ddba015f14d0aa81aa4d67f612c76u.png" alt="image.png"><br><img src="https://ae03.alicdn.com/kf/H332e4e195f884a3886c1dd45f4a7b7dcu.png" alt="image.png"><br><img src="https://ae04.alicdn.com/kf/H67ad2cf002344229bd4591f89efd58b6n.png" alt="image.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带图片的toast的实现</title>
      <link href="/2020/06/12/dai-tu-pian-de-toast-de-shi-xian/"/>
      <url>/2020/06/12/dai-tu-pian-de-toast-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="带图片toast的实现"><a href="#带图片toast的实现" class="headerlink" title="带图片toast的实现"></a>带图片toast的实现</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近刚开始接触Android开发，算是进入了到了一个新领域。对于一个门外汉来讲，再简单的知识对他而言也是全新的。闻道有先后，术业有专攻，如是而已。这次介绍一下用到的带图片的toast的实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以自己创建一个ToastUtil类，提供showToast方法，在需要的时候调用即可。</p><pre><code>import android.content.Context;import android.view.Display;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.bilibili.bletester.R;public class ToastUtil extends Toast {    private static Toast mToast;    public ToastUtil(Context context) {        super(context);    }    public static void showToast(Context context, String content){    //获取系统的LayoutInflater        LayoutInflater inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);        View view = inflater.inflate(R.layout.toast_layout,null);        TextView tv_content = view.findViewById(R.id.tv_content);        tv_content.setText(content);        //实例化toast        mToast = new Toast(context);        mToast.setView(view);        mToast.setDuration(Toast.LENGTH_SHORT);    //这里可以设置toast默认显示的位置，当不进行设置时，则默认显示在屏幕下方       // mToast.setGravity(Gravity.BOTTOM,);        //mToast.setGravity(Gravity.BOTTOM,0,100);        mToast.show();    }}</code></pre><p>同时，在drawable中添加要显示的图片，注意添加图片不要太大，自己调试到合适尺寸，<br>如本例中添加了wetchat.jpg图片</p><p><img src="https://pic.rmb.bdstatic.com/bjh/22c1a0811abcaad1fccb7f60a147f520.png" alt="image.png"></p><p>在layout包下添加toast_layout.xml文件，内容如下</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:orientation="vertical"&gt;    &lt;ImageView        android:id="@+id/imageView"        android:layout_width="100dp"        android:layout_height="100dp"        android:layout_marginBottom="10dp"        android:scaleType="fitCenter"        app:srcCompat="@drawable/wechat" /&gt;    &lt;TextView        android:id="@+id/tv_content"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:gravity="center"        android:paddingLeft="18dp"        android:paddingTop="11dp"        android:paddingRight="18dp"        android:paddingBottom="11dp"        android:text="提醒成功"        android:textColor="?attr/colorAccent"        android:textSize="16sp" /&gt;&lt;/LinearLayout&gt;</code></pre><p>添加图片的关键在于中间的ImageView字段，配置图片与文字呈上下显示的字段是<br>android:orientation=”vertical”&gt;，<br>接下来进行测试，我在mainActivity.java中定义了如下函数：</p><pre><code>//测试ToastUtil类public void toast_test(View view){    ToastUtil.showToast(this,"lalala");}</code></pre><p>然后在activity_main.xml中添加如下一个按钮，即可实现调用了</p><pre><code>&lt;Button    android:id="@+id/button"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="Button"    android:onClick="toast_test"    app:layout_constraintBottom_toTopOf="@+id/textView"    app:layout_constraintEnd_toEndOf="parent"    app:layout_constraintStart_toStartOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;</code></pre><p>测试结果如下：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/9efe6df56e8b5913b17846ac83477758.png" alt="image.png"></p><p>其中server和client两个button是做其他用的，和这里的功能无关</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2020/06/05/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2020/06/05/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><p>因为前段时间在公司项目中一个场景下需要用到观察者模式，所以在此做一个记录。</p><p>我遇到的问题是，在一个参数设置页面设置参数后，需要其它依赖这个参数的对象同时更新这些参数，如果采用后者不断去轮询的方式，一来消耗性能，二来也不能保证得到及时的更新，所以考虑使用观察者模式。</p><p>观察者模式(<em>Observer Pattern</em>)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。<br>观察者模式是一种对象行为型模式。<br>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式中有“观察者” 和 “被观察者”，举个例子，微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是<em>被观察者<em>，而用户就是</em>观察者</em></p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><p><img src="https://ae03.alicdn.com/kf/U1cffe803ca594bc7891c087dbcb28682c.png" alt="1"><br><img src="https://ae04.alicdn.com/kf/Udb3f3bbee22d4e5096b87aafaffdb4cfX.png" alt="2"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="Subject（目标）"><a href="#Subject（目标）" class="headerlink" title="Subject（目标）"></a>Subject（目标）</h4><p>被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p><h4 id="ConcreteSubject（具体目标）："><a href="#ConcreteSubject（具体目标）：" class="headerlink" title="ConcreteSubject（具体目标）："></a>ConcreteSubject（具体目标）：</h4><p>具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><h4 id="Observer（观察者）："><a href="#Observer（观察者）：" class="headerlink" title="Observer（观察者）："></a>Observer（观察者）：</h4><p>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。<br>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update()方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>定义观察者接口</li></ol><pre><code>    interface Observer {        public void update();`    }</code></pre><ol start="2"><li>定义被观察者</li></ol><pre><code>abstract class Subject {    private Vector&lt;Observer&gt; obs = new Vector();    public void addObserver(Observer obs){        this.obs.add(obs);    }    public void delObserver(Observer obs){        this.obs.remove(obs);    }    protected void notifyObserver(){        for(Observer o: obs){            o.update();        }    }    public abstract void doSomething();}</code></pre><ol start="3"><li><p>具体的被观察者</p><pre><code>class ConcreteSubject extends Subject { public void doSomething(){     System.out.println("被观察者事件发生改变");     this.notifyObserver(); }}</code></pre></li><li><p>具体的被观察者</p><pre><code>class ConcreteObserver1 implements Observer { public void update() {     System.out.println("观察者1收到信息，并进行处理"); }}class ConcreteObserver2 implements Observer { public void update() {     System.out.println("观察者2收到信息，并进行处理"); }}</code></pre></li><li><p>客户端</p><pre><code>public class Client { public static void main(String[] args){     Subject sub = new ConcreteSubject();     sub.addObserver(new ConcreteObserver1()); //添加观察者1     sub.addObserver(new ConcreteObserver2()); //添加观察者2     sub.doSomething(); }}</code></pre></li></ol><p>输出</p><p><em>被观察者事件发生改变</em></p><p><em>观察者1收到信息，并进行处理</em></p><p><em>观察者2收到信息，并进行处理复制代码</em></p><p>通过运行结果可以看到，我们只调用了 Subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 Subject 类中关联一下 Observer 类，并且在 doSomething() 方法中遍历一下 Observer 的 update() 方法就行了。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系<br>目标与观察者之间建立了一套触发机制<br>支持广播通信<br>符合“开闭原则”的要求</p><p><strong>缺点</strong></p><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用<br>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</p><p><strong>应用</strong></p><p>JDK中的观察者模式<br>观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持，但在 Java9 被弃用了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 中的中文乱码问题</title>
      <link href="/2020/05/21/springmvc-zhong-de-zhong-wen-luan-ma-wen-ti/"/>
      <url>/2020/05/21/springmvc-zhong-de-zhong-wen-luan-ma-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-中的中文乱码问题"><a href="#SpringMVC-中的中文乱码问题" class="headerlink" title="SpringMVC 中的中文乱码问题"></a>SpringMVC 中的中文乱码问题</h1><p>在前段时间玩的一个SSM项目中，遇到了不少中文乱码的问题，经常读出的数据变成了“？？？”，我也是一脸 ？？？，现在做个小记录。</p><p>其实除了在SpringMVC中有中文乱码的问题，在MyBatis中同样存在，一般是编码方式不统一导致的，大部分可以通过配置文件去解决，至于不能解决的那部分，只是我还没碰到罢了。</p><h3 id="分门别类："><a href="#分门别类：" class="headerlink" title="分门别类："></a>分门别类：</h3><h4 id="1-要在web-xm中配置拦截器"><a href="#1-要在web-xm中配置拦截器" class="headerlink" title="1. 要在web.xm中配置拦截器"></a>1. 要在web.xm中配置拦截器</h4><p>注意web.xml的配置要遵守一定的顺叙,一个样例如下：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</code></pre><p> 配置路径，以使得监听器能去加载spring的配置文件applicationContext,配置好之后，就能在**tController类中使用依赖注入了</p><pre><code>  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--解决中文乱码的问题，设置过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;!--设定编码集--&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;!--设置该字符过滤器要拦截的内容--&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;!--表示所有的内容都被此过滤器拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><p> 配置监听器，因为启动服务器后，加载web.xml文件，根据此文件加载springMVC的配置文件，而没有去加载spring的配置文件，<br>  所以需要设置此监听器，当服务器启动开始加载servletContext对象时，也去加载spring的配置文件<br> 但该监听器 默认只加载WEB-INF目录下的applicationContext.xml配置文件，所以下面还需要配置其路径</p><pre><code>&lt;listener&gt;  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;  &lt;!--这里是配置前端控制器--&gt;  &lt;!--希望做的是 1.加载springMVC.xml配置文件  &lt;                1. 启动服务器，就创建该servlet--&gt; &lt;servlet&gt;   &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;   &lt;!--加载springMVC配置文件，springMVC.xml配置文件在resources目录下进行创建，   创建的方法是：右键resources-&gt;new-&gt;选择xml configuration File-&gt;选择Spring config-&gt;命名为springMVC.xml--&gt;   &lt;init-param&gt;     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;     &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;   &lt;/init-param&gt;   &lt;!--启动服务器，创建该servlet--&gt;   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="2-数据库的编码方式"><a href="#2-数据库的编码方式" class="headerlink" title="2. 数据库的编码方式"></a>2. 数据库的编码方式</h4><p>(一)：数据库端字符集设置</p><p>　　1. 安装mysql时，会有一个数据库编码设置，将其设置为utf-8</p><p>　　2. 先设置数据库的字符集属性；</p><p>　　3. 将要显示中文的字段设置为UTF-8</p><p>springMVC项目，存中文到mysql是乱码（?????）<br>问题：jdbc连接mysql数据库，web页面输入的中文，存到数据库却变成”？？？？”；</p><p>　　但是数据库中的中文却能够正常读出并在页面显示<br>mysql中运行 ：SHOW VARIABLES LIKE ‘char%’</p><p>发现唯一一个不是utf8的是character_set_server这个参数。</p><p>在my.cnf中，mysqld下添加“character-set-server=utf8”</p><p>重启mysql后，问题解决。</p><h4 id="3-检查Spring的配置文件"><a href="#3-检查Spring的配置文件" class="headerlink" title="3. 检查Spring的配置文件"></a>3. 检查Spring的配置文件</h4><p>如果web.xml和数据库的编码格式都设置为了utf8，仍存到数据库之后为乱码<br>则有可能是传输的时候出现了问题，所以继续检查spring的配置文件applicationContext.xml中，配置连接池时，url配置是否加上了编码方式，如下：</p><p>这时spring配置中整合spring与mybatis的其中一段配置，这是配置连接池的，在url后面指定传输时的数据编码格式为utf8</p><pre><code> &lt;!--配置连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;!--配置四个属性--&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm?characterEncoding=utf8"/&gt;    &lt;property name="user" value="root"/&gt;    &lt;property name="password" value=""/&gt;&lt;/bean&gt;</code></pre><h4 id="4-补充：Mybatis-中的中文乱码"><a href="#4-补充：Mybatis-中的中文乱码" class="headerlink" title="4. 补充：Mybatis 中的中文乱码"></a>4. 补充：Mybatis 中的中文乱码</h4><p>mybatis操作数据的乱码有两种，一是数据库本身插入中文就显示乱码，这个可以通过修改库或者表的编码格式进行修改或者在建表的时候就选择utf8的编码格式。</p><p>第二种是mybatis传入中文数据到数据库，建库时设置了数据库默认字符集为UTF-8，通过mysql workbench直接插入中文显示完全正常。但是使用mybaits插入数据时，中文显示成了”???”这样的乱码。但从数据库获取的中文不会乱码。跟踪数据库操作，SQL语句中的中文还是显示正常的，但是插入到mysql数据库后就乱码了，于是判断可能是数据库连接的问题。后来在网上找了下资料，发现确实可以为mysql数据库的连接字符串设置编码方式，如下：</p><pre><code>jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始话</title>
      <link href="/2020/05/17/chu-shi-hua-1/"/>
      <url>/2020/05/17/chu-shi-hua-1/</url>
      
        <content type="html"><![CDATA[<p>有自己的空间是件有意思的事情。</p><p>做好这个小房子前，其实并没有想好要往里边放什么，这是很奇怪的。木匠做好一个柜子前，他应该先想好这是个衣柜还是鞋柜。然而现在先把柜子做好了，我需要停下来，考虑拿它来干什么用。这又引出了另外一个问题，我能做什么？得先知道自己能做出什么事情，才能知道有什么事情交给别人做，毫无疑问，知道自己究竟能做什么是件很难的事情，但我大致想好了。</p><p>其一是日常所学。闻道有先后，我并不介意自己分享十分基础的知识，我其实能想象得到，每过一段时间回头再看，都会发现自己以前的愚蠢与浅薄。但假如真的能做到这样，说明我还是有所进步的，否认以前的自己并不完全是件坏事。</p><p>身上的烟火气息提醒我，平日里的柴米油盐，嬉笑怒骂同样珍贵，或许哪天上的是一则游记，或许是一个菜谱，或许是一个笑话，或奇闻，或五行八卦阴阳异术……还是回到之前的问题：我到底会什么？</p><pre><code>“you know nothing”---- Ygritte</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始话</title>
      <link href="/2020/05/17/chu-shi-hua/"/>
      <url>/2020/05/17/chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>有自己的空间是件有意思的事情。</p><p>做好这个小房子前，其实并没有想好要往里边放什么，这是很奇怪的。木匠做好一个柜子前，他应该先想好这是个衣柜还是鞋柜。然而现在先把柜子做好了，我需要停下来，考虑拿它来干什么用。这又引出了另外一个问题，我能做什么？得先知道自己能做出什么事情，才能知道有什么事情交给别人做，毫无疑问，知道自己究竟能做什么是件很难的事情，但我大致想好了。</p><p>其一是日常所学。闻道有先后，我并不介意自己分享十分基础的知识，我其实能想象得到，每过一段时间回头再看，都会发现自己以前的愚蠢与浅薄。但假如真的能做到这样，说明我还是有所进步的，否认以前的自己并不完全是件坏事。</p><p>身上的烟火气息提醒我，平日里的柴米油盐，嬉笑怒骂同样珍贵，或许哪天上的是一则游记，或许是一个菜谱，或许是一个笑话，或奇闻，或五行八卦阴阳异术……还是回到之前的问题：我到底会什么？</p><pre><code>“you know nothing”---- Ygritte</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
