<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之建造者模式</title>
      <link href="/2020/07/01/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/"/>
      <url>/2020/07/01/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之建造者模式"><a href="#设计模式之建造者模式" class="headerlink" title="设计模式之建造者模式"></a>设计模式之建造者模式</h1><p>在java中实例化某个类的对象时，我们会经常碰到 <em>**bulider</em> 这样的形式，这其实是使用的就是建造者模式。但是为什么不直接用普通的方法去实例化，而要这么绕一下呢？这种情况我觉得在设计模式中经常遇到，比如工厂模式也是如此，代理模式也是如此，总的来说，这样的看似“多余”的做法，其实是在设计原则的指导下而形成的。一般来说，当一个类的构造函数参数个数较多，而且这些参数有些是可选的参数，就可以考虑使用建造者模式。</p><p>我们先从一个例子说起。</p><p>例如我们现在有如下一个类计算机类Computer，其中cpu与ram是必填参数，而其他3个是可选参数，那么我们如何构造这个类的实例呢,通常有两种常用的方式：</p><pre><code>public class Computer {    private String cpu;//必须    private String ram;//必须    private int usbCount;//可选    private String keyboard;//可选    private String display;//可选}</code></pre><p>第一：折叠构造函数模式（telescoping constructor pattern ），这个我们经常用,如下代码所示</p><pre><code>public class Computer {     ...    public Computer(String cpu, String ram) {        this(cpu, ram, 0);    }    public Computer(String cpu, String ram, int usbCount) {        this(cpu, ram, usbCount, "罗技键盘");    }    public Computer(String cpu, String ram, int usbCount, String keyboard) {        this(cpu, ram, usbCount, keyboard, "三星显示器");    }    public Computer(String cpu, String ram, int usbCount, String keyboard, String display) {        this.cpu = cpu;        this.ram = ram;        this.usbCount = usbCount;        this.keyboard = keyboard;        this.display = display;    }}</code></pre><p>第二种：Javabean 模式，如下所示</p><pre><code>public class Computer {        ...    public String getCpu() {        return cpu;    }    public void setCpu(String cpu) {        this.cpu = cpu;    }    public String getRam() {        return ram;    }    public void setRam(String ram) {        this.ram = ram;    }    public int getUsbCount() {        return usbCount;    }...}</code></pre><p>那么这两种方式有什么弊端呢？ 第一种主要是使用及阅读不方便。你可以想象一下，当你要调用一个类的构造函数时，你首先要决定使用哪一个，然后里面又是一堆参数，如果这些参数的类型很多又都一样，你还要搞清楚这些参数的含义，很容易就传混了。。。那酸爽谁用谁知道。 第二种方式在构建过程中对象的状态容易发生变化，造成错误。因为那个类中的属性是分步设置的，所以就容易出错。<br>为了解决这两个痛点，builder模式就横空出世了。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><ul><li><p>在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。</p></li><li><p>在Computer中创建一个private的构造函数，参数为Builder类型</p></li><li><p>在Builder中创建一个public的构造函数，参数为Computer中必填的那些参数，cpu 和ram。</p></li><li><p>在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例</p></li><li><p>在Builder中创建一个build()方法，在其中构建Computer的实例并返回<br>下面代码就是最终的样子</p><pre><code>public class Computer {  private final String cpu;//必须  private final String ram;//必须  private final int usbCount;//可选  private final String keyboard;//可选  private final String display;//可选  private Computer(Builder builder){      this.cpu=builder.cpu;      this.ram=builder.ram;      this.usbCount=builder.usbCount;      this.keyboard=builder.keyboard;      this.display=builder.display;  }  public static class Builder{      private String cpu;//必须      private String ram;//必须      private int usbCount;//可选      private String keyboard;//可选      private String display;//可选      public Builder(String cup,String ram){          this.cpu=cup;          this.ram=ram;      }      public Builder setUsbCount(int usbCount) {          this.usbCount = usbCount;          return this;      }      public Builder setKeyboard(String keyboard) {          this.keyboard = keyboard;          return this;      }      public Builder setDisplay(String display) {          this.display = display;          return this;      }              public Computer build(){          return new Computer(this);      }  }}</code></pre></li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在客户端使用链式调用，一步一步的把对象构建出来。</p><pre><code>Computer computer=new Computer.Builder("因特尔","三星")                .setDisplay("三星24寸")                .setKeyboard("罗技")                .setUsbCount(2)                .build();</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>构建者模式是一个非常实用而常见的创建类型的模式（creational design pattern)，例如图片处理框架Glide，网络请求框架Retrofit等都使用了此模式。</p><p><strong>扩展</strong></p><p>其实上面的内容是Builder在Java中一种简化的使用方式，经典的Builder 模式与其有一定的不同，如果没有兴趣的同学就可以不用往下读了。</p><h3 id="建造者模式-VS-简单工厂模式"><a href="#建造者模式-VS-简单工厂模式" class="headerlink" title="建造者模式 VS 简单工厂模式"></a>建造者模式 VS 简单工厂模式</h3><p><strong>相似点</strong></p><p>它们都属于创建型模式「都是创建产品的」</p><p><strong>区别</strong></p><ol><li>创建对象的粒度不同<br>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</li><li>关注点不同：<br>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</li></ol><h3 id="补充：-静态内部类和非静态内部类区别"><a href="#补充：-静态内部类和非静态内部类区别" class="headerlink" title="补充： 静态内部类和非静态内部类区别"></a>补充： 静态内部类和非静态内部类区别</h3><p><strong>总结</strong></p><ol><li><p>是否能拥有静态成员<br>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)</p></li><li><p>访问外部类的成员<br>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</p></li><li><p>静态内部类和非静态内部类在创建时有区别<br>//假设类A有静态内部类B和非静态内部类C，创建B和C的区别为：</p><pre><code>A a=new A(); A.B b=new A.B(); A.C c=a.new C();</code></pre></li></ol><p><strong>在建造者模式中使用静态内部类的原因:</strong></p><p>静态内部类相当于是一个独立的类，但是如果某个类A只想被类B使用，则可以把A作为静态内部类放到B中，这样就能B.A.method()这样去使用了，相当于在A的前面加了一个限定符，避免A放在外面时，被其他类所依赖。同时，在外部类没有初始化时，同样可以初始化静态内部类，如上面的做法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2020/05/26/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2020/05/26/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><p>因为前段时间在公司项目中一个场景下需要用到观察者模式，所以在此做一个记录。</p><p>我遇到的问题是，在一个参数设置页面设置参数后，需要其它依赖这个参数的对象同时更新这些参数，如果采用后者不断去轮询的方式，一来消耗性能，二来也不能保证得到及时的更新，所以考虑使用观察者模式。</p><p>观察者模式(<em>Observer Pattern</em>)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。<br>观察者模式是一种对象行为型模式。<br>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式中有“观察者” 和 “被观察者”，举个例子，微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是<em>被观察者<em>，而用户就是</em>观察者</em></p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><p><img src="https://ae03.alicdn.com/kf/U1cffe803ca594bc7891c087dbcb28682c.png" alt="1"><br><img src="https://ae04.alicdn.com/kf/Udb3f3bbee22d4e5096b87aafaffdb4cfX.png" alt="2"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="Subject（目标）"><a href="#Subject（目标）" class="headerlink" title="Subject（目标）"></a>Subject（目标）</h4><p>被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p><h4 id="ConcreteSubject（具体目标）："><a href="#ConcreteSubject（具体目标）：" class="headerlink" title="ConcreteSubject（具体目标）："></a>ConcreteSubject（具体目标）：</h4><p>具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><h4 id="Observer（观察者）："><a href="#Observer（观察者）：" class="headerlink" title="Observer（观察者）："></a>Observer（观察者）：</h4><p>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。<br>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update()方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>定义观察者接口</li></ol><pre><code>    interface Observer {        public void update();`    }</code></pre><ol start="2"><li>定义被观察者</li></ol><pre><code>abstract class Subject {    private Vector&lt;Observer&gt; obs = new Vector();    public void addObserver(Observer obs){        this.obs.add(obs);    }    public void delObserver(Observer obs){        this.obs.remove(obs);    }    protected void notifyObserver(){        for(Observer o: obs){            o.update();        }    }    public abstract void doSomething();}</code></pre><ol start="3"><li><p>具体的被观察者</p><pre><code>class ConcreteSubject extends Subject { public void doSomething(){     System.out.println("被观察者事件发生改变");     this.notifyObserver(); }}</code></pre></li><li><p>具体的被观察者</p><pre><code>class ConcreteObserver1 implements Observer { public void update() {     System.out.println("观察者1收到信息，并进行处理"); }}class ConcreteObserver2 implements Observer { public void update() {     System.out.println("观察者2收到信息，并进行处理"); }}</code></pre></li><li><p>客户端</p><pre><code>public class Client { public static void main(String[] args){     Subject sub = new ConcreteSubject();     sub.addObserver(new ConcreteObserver1()); //添加观察者1     sub.addObserver(new ConcreteObserver2()); //添加观察者2     sub.doSomething(); }}</code></pre></li></ol><p>输出</p><p><em>被观察者事件发生改变</em></p><p><em>观察者1收到信息，并进行处理</em></p><p><em>观察者2收到信息，并进行处理复制代码</em></p><p>通过运行结果可以看到，我们只调用了 Subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 Subject 类中关联一下 Observer 类，并且在 doSomething() 方法中遍历一下 Observer 的 update() 方法就行了。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系<br>目标与观察者之间建立了一套触发机制<br>支持广播通信<br>符合“开闭原则”的要求</p><p><strong>缺点</strong></p><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用<br>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</p><p><strong>应用</strong></p><p>JDK中的观察者模式<br>观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持（可以去查看下源码，写的比较严谨）。but，在 Java9 被弃用了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 中的中文乱码问题</title>
      <link href="/2020/05/21/springmvc-zhong-de-zhong-wen-luan-ma-wen-ti/"/>
      <url>/2020/05/21/springmvc-zhong-de-zhong-wen-luan-ma-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-中的中文乱码问题"><a href="#SpringMVC-中的中文乱码问题" class="headerlink" title="SpringMVC 中的中文乱码问题"></a>SpringMVC 中的中文乱码问题</h1><p>在前段时间玩的一个SSM项目中，遇到了不少中文乱码的问题，经常读出的数据变成了“？？？”，我也是一脸 ？？？，现在做个小记录。</p><p>其实除了在SpringMVC中有中文乱码的问题，在MyBatis中同样存在，一般是编码方式不统一导致的，大部分可以通过配置文件去解决，至于不能解决的那部分，只是我还没碰到罢了。</p><h3 id="分门别类："><a href="#分门别类：" class="headerlink" title="分门别类："></a>分门别类：</h3><h4 id="1-要在web-xm中配置拦截器"><a href="#1-要在web-xm中配置拦截器" class="headerlink" title="1. 要在web.xm中配置拦截器"></a>1. 要在web.xm中配置拦截器</h4><p>注意web.xml的配置要遵守一定的顺叙,一个样例如下：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</code></pre><p> 配置路径，以使得监听器能去加载spring的配置文件applicationContext,配置好之后，就能在**tController类中使用依赖注入了</p><pre><code>  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--解决中文乱码的问题，设置过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;!--设定编码集--&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;!--设置该字符过滤器要拦截的内容--&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;!--表示所有的内容都被此过滤器拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><p> 配置监听器，因为启动服务器后，加载web.xml文件，根据此文件加载springMVC的配置文件，而没有去加载spring的配置文件，<br>  所以需要设置此监听器，当服务器启动开始加载servletContext对象时，也去加载spring的配置文件<br> 但该监听器 默认只加载WEB-INF目录下的applicationContext.xml配置文件，所以下面还需要配置其路径</p><pre><code>&lt;listener&gt;  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;  &lt;!--这里是配置前端控制器--&gt;  &lt;!--希望做的是 1.加载springMVC.xml配置文件  &lt;                1. 启动服务器，就创建该servlet--&gt; &lt;servlet&gt;   &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;   &lt;!--加载springMVC配置文件，springMVC.xml配置文件在resources目录下进行创建，   创建的方法是：右键resources-&gt;new-&gt;选择xml configuration File-&gt;选择Spring config-&gt;命名为springMVC.xml--&gt;   &lt;init-param&gt;     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;     &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;   &lt;/init-param&gt;   &lt;!--启动服务器，创建该servlet--&gt;   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="2-数据库的编码方式"><a href="#2-数据库的编码方式" class="headerlink" title="2. 数据库的编码方式"></a>2. 数据库的编码方式</h4><p>(一)：数据库端字符集设置</p><p>　　1. 安装mysql时，会有一个数据库编码设置，将其设置为utf-8</p><p>　　2. 先设置数据库的字符集属性；</p><p>　　3. 将要显示中文的字段设置为UTF-8</p><p>springMVC项目，存中文到mysql是乱码（?????）<br>问题：jdbc连接mysql数据库，web页面输入的中文，存到数据库却变成”？？？？”；</p><p>　　但是数据库中的中文却能够正常读出并在页面显示<br>mysql中运行 ：SHOW VARIABLES LIKE ‘char%’</p><p>发现唯一一个不是utf8的是character_set_server这个参数。</p><p>在my.cnf中，mysqld下添加“character-set-server=utf8”</p><p>重启mysql后，问题解决。</p><h4 id="3-检查Spring的配置文件"><a href="#3-检查Spring的配置文件" class="headerlink" title="3. 检查Spring的配置文件"></a>3. 检查Spring的配置文件</h4><p>如果web.xml和数据库的编码格式都设置为了utf8，仍存到数据库之后为乱码<br>则有可能是传输的时候出现了问题，所以继续检查spring的配置文件applicationContext.xml中，配置连接池时，url配置是否加上了编码方式，如下：</p><p>这时spring配置中整合spring与mybatis的其中一段配置，这是配置连接池的，在url后面指定传输时的数据编码格式为utf8</p><pre><code> &lt;!--配置连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;!--配置四个属性--&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm?characterEncoding=utf8"/&gt;    &lt;property name="user" value="root"/&gt;    &lt;property name="password" value=""/&gt;&lt;/bean&gt;</code></pre><h4 id="4-补充：Mybatis-中的中文乱码"><a href="#4-补充：Mybatis-中的中文乱码" class="headerlink" title="4. 补充：Mybatis 中的中文乱码"></a>4. 补充：Mybatis 中的中文乱码</h4><p>mybatis操作数据的乱码有两种，一是数据库本身插入中文就显示乱码，这个可以通过修改库或者表的编码格式进行修改或者在建表的时候就选择utf8的编码格式。</p><p>第二种是mybatis传入中文数据到数据库，建库时设置了数据库默认字符集为UTF-8，通过mysql workbench直接插入中文显示完全正常。但是使用mybaits插入数据时，中文显示成了”???”这样的乱码。但从数据库获取的中文不会乱码。跟踪数据库操作，SQL语句中的中文还是显示正常的，但是插入到mysql数据库后就乱码了，于是判断可能是数据库连接的问题。后来在网上找了下资料，发现确实可以为mysql数据库的连接字符串设置编码方式，如下：</p><pre><code>jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Activity</title>
      <link href="/2020/05/19/qian-tan-activity/"/>
      <url>/2020/05/19/qian-tan-activity/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Activity"><a href="#什么是Activity" class="headerlink" title="什么是Activity"></a>什么是Activity</h2><ol><li>Activity一直是一个老生长谈的问题，大概是因为用的多，所以谈论的自然也多一些。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开门第一话</title>
      <link href="/2020/05/17/kai-men-di-yi-hua/"/>
      <url>/2020/05/17/kai-men-di-yi-hua/</url>
      
        <content type="html"><![CDATA[<p>有自己的空间是件有意思的事情。</p><p>做好这个小房子前，其实并没有想好要往里边放什么，这是很奇怪的。木匠做好一个柜子前，他应该先想好这是个衣柜还是鞋柜。然而现在先把柜子做好了，我需要停下来，考虑拿它来干什么用。这又引出了另外一个问题，我能做什么？得先知道自己能做出什么事情，才能知道有什么事情交给别人做，毫无疑问，知道自己究竟能做什么是件很难的事情，但我大致想好了。</p><p>其一是日常所学。闻道有先后，我并不介意自己分享十分基础的知识，我其实能想象得到，每过一段时间回头再看，都会发现自己以前的愚蠢与浅薄。但假如真的能做到这样，说明我还是有所进步的，否认以前的自己并不完全是件坏事。</p><p>身上的烟火气息提醒我，平日里的柴米油盐，嬉笑怒骂同样珍贵，或许哪天上的是一则游记，或许是一个菜谱，或许是一个笑话，或奇闻，或五行八卦阴阳异术……还是回到之前的问题：我到底会什么？</p><pre><code>“you know nothing”---- Ygritte</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
