<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之建造者模式</title>
      <link href="/2020/08/02/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/"/>
      <url>/2020/08/02/she-ji-mo-shi-zhi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之建造者模式"><a href="#设计模式之建造者模式" class="headerlink" title="设计模式之建造者模式"></a>设计模式之建造者模式</h1><p>在java中实例化某个类的对象时，我们会经常碰到 <em>**bulider</em> 这样的形式，这其实是使用的就是建造者模式。但是为什么不直接用普通的方法去实例化，而要这么绕一下呢？这种情况我觉得在设计模式中经常遇到，比如工厂模式也是如此，代理模式也是如此，总的来说，这样的看似“多余”的做法，其实是在设计原则的指导下而形成的。一般来说，当一个类的构造函数参数个数较多，而且这些参数有些是可选的参数，就可以考虑使用建造者模式。</p><p>我们先从一个例子说起。</p><p>例如我们现在有如下一个类计算机类Computer，其中cpu与ram是必填参数，而其他3个是可选参数，那么我们如何构造这个类的实例呢,通常有两种常用的方式：</p><pre><code>public class Computer {    private String cpu;//必须    private String ram;//必须    private int usbCount;//可选    private String keyboard;//可选    private String display;//可选}</code></pre><p>第一：折叠构造函数模式（telescoping constructor pattern ），这个我们经常用,如下代码所示</p><pre><code>public class Computer {     ...    public Computer(String cpu, String ram) {        this(cpu, ram, 0);    }    public Computer(String cpu, String ram, int usbCount) {        this(cpu, ram, usbCount, "罗技键盘");    }    public Computer(String cpu, String ram, int usbCount, String keyboard) {        this(cpu, ram, usbCount, keyboard, "三星显示器");    }    public Computer(String cpu, String ram, int usbCount, String keyboard, String display) {        this.cpu = cpu;        this.ram = ram;        this.usbCount = usbCount;        this.keyboard = keyboard;        this.display = display;    }}</code></pre><p>第二种：Javabean 模式，如下所示</p><pre><code>public class Computer {        ...    public String getCpu() {        return cpu;    }    public void setCpu(String cpu) {        this.cpu = cpu;    }    public String getRam() {        return ram;    }    public void setRam(String ram) {        this.ram = ram;    }    public int getUsbCount() {        return usbCount;    }...}</code></pre><p>那么这两种方式有什么弊端呢？ 第一种主要是使用及阅读不方便。你可以想象一下，当你要调用一个类的构造函数时，你首先要决定使用哪一个，然后里面又是一堆参数，如果这些参数的类型很多又都一样，你还要搞清楚这些参数的含义，很容易就传混了。。。那酸爽谁用谁知道。 第二种方式在构建过程中对象的状态容易发生变化，造成错误。因为那个类中的属性是分步设置的，所以就容易出错。<br>为了解决这两个痛点，builder模式就横空出世了。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><ul><li><p>在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。</p></li><li><p>在Computer中创建一个private的构造函数，参数为Builder类型</p></li><li><p>在Builder中创建一个public的构造函数，参数为Computer中必填的那些参数，cpu 和ram。</p></li><li><p>在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例</p></li><li><p>在Builder中创建一个build()方法，在其中构建Computer的实例并返回<br>下面代码就是最终的样子</p><pre><code>public class Computer {  private final String cpu;//必须  private final String ram;//必须  private final int usbCount;//可选  private final String keyboard;//可选  private final String display;//可选  private Computer(Builder builder){      this.cpu=builder.cpu;      this.ram=builder.ram;      this.usbCount=builder.usbCount;      this.keyboard=builder.keyboard;      this.display=builder.display;  }  public static class Builder{      private String cpu;//必须      private String ram;//必须      private int usbCount;//可选      private String keyboard;//可选      private String display;//可选      public Builder(String cup,String ram){          this.cpu=cup;          this.ram=ram;      }      public Builder setUsbCount(int usbCount) {          this.usbCount = usbCount;          return this;      }      public Builder setKeyboard(String keyboard) {          this.keyboard = keyboard;          return this;      }      public Builder setDisplay(String display) {          this.display = display;          return this;      }              public Computer build(){          return new Computer(this);      }  }}</code></pre></li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在客户端使用链式调用，一步一步的把对象构建出来。</p><pre><code>Computer computer=new Computer.Builder("因特尔","三星")                .setDisplay("三星24寸")                .setKeyboard("罗技")                .setUsbCount(2)                .build();</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>构建者模式是一个非常实用而常见的创建类型的模式（creational design pattern)，例如图片处理框架Glide，网络请求框架Retrofit等都使用了此模式。</p><p>在我使用的过程中，是设置蓝牙过滤器时使用到ScanFilter这个类：</p><pre><code>ScanFilter filter = new ScanFilter.Builder().setDeviceAddress(address).build();</code></pre><p>在ScanFilter中，具体的定义方式与上面给出的不太一样，这里节选其中的部分代码：</p><pre><code>public final class ScanFilter implements Parcelable {    @Nullable    private final String mDeviceName;    @Nullable    private final String mDeviceAddress;    @Nullable    private final ParcelUuid mServiceUuid;    @Nullable    private final ParcelUuid mServiceUuidMask;    ....    ....    @Nullable    private final byte[] mManufacturerDataMask;    /** @hide */    public static final ScanFilter EMPTY = new ScanFilter.Builder().build();    private ScanFilter(String name, String deviceAddress, ParcelUuid uuid,            ParcelUuid uuidMask, ParcelUuid solicitationUuid,            ParcelUuid solicitationUuidMask, ParcelUuid serviceDataUuid,            byte[] serviceData, byte[] serviceDataMask,            int manufacturerId, byte[] manufacturerData, byte[] manufacturerDataMask) {        mDeviceName = name;        mServiceUuid = uuid;        mServiceUuidMask = uuidMask;        ....        ....        mManufacturerData = manufacturerData;        mManufacturerDataMask = manufacturerDataMask;    }public static final class Builder {        private String mDeviceName;        private String mDeviceAddress;        private ParcelUuid mServiceUuid;        private ParcelUuid mUuidMask;        ....        ....        ....        private byte[] mManufacturerDataMask;        public Builder setDeviceName(String deviceName) {            mDeviceName = deviceName;            return this;        }        public Builder setDeviceAddress(String deviceAddress) {            if (deviceAddress != null &amp;&amp; !BluetoothAdapter.checkBluetoothAddress(deviceAddress)) {                throw new IllegalArgumentException("invalid device address " + deviceAddress);            }            mDeviceAddress = deviceAddress;            return this;        }     public ScanFilter build() {            return new ScanFilter(mDeviceName, mDeviceAddress,                    mServiceUuid, mUuidMask, mServiceSolicitationUuid,                    ....                    ....                    mManufacturerId, mManufacturerData, mManufacturerDataMask);        }    }</code></pre><p>在ScanFilter的构造函数中，不是传入的Builder对象，而是直接将设置后的参数传入ScanFilter中，不过这与前面的例子本质是一致的，都是通过build()方法去调用外部类的构造方法。<br><strong>扩展</strong></p><p>其实上面的内容是Builder在Java中一种简化的使用方式，经典的Builder 模式与其有一定的不同，如果没有兴趣的同学就可以不用往下读了。</p><h3 id="建造者模式-VS-简单工厂模式"><a href="#建造者模式-VS-简单工厂模式" class="headerlink" title="建造者模式 VS 简单工厂模式"></a>建造者模式 VS 简单工厂模式</h3><p><strong>相似点</strong></p><p>它们都属于创建型模式「都是创建产品的」</p><p><strong>区别</strong></p><ol><li>创建对象的粒度不同<br>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</li><li>关注点不同：<br>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</li></ol><h3 id="补充：-静态内部类和非静态内部类区别"><a href="#补充：-静态内部类和非静态内部类区别" class="headerlink" title="补充： 静态内部类和非静态内部类区别"></a>补充： 静态内部类和非静态内部类区别</h3><p><strong>总结</strong></p><ol><li><p>是否能拥有静态成员<br>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)</p></li><li><p>访问外部类的成员<br>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</p></li><li><p>静态内部类和非静态内部类在创建时有区别<br>//假设类A有静态内部类B和非静态内部类C，创建B和C的区别为：</p><pre><code>A a=new A(); A.B b=new A.B(); A.C c=a.new C();</code></pre></li></ol><p><strong>在建造者模式中使用静态内部类的原因:</strong></p><p>静态内部类相当于是一个独立的类，但是如果某个类A只想被类B使用，则可以把A作为静态内部类放到B中，这样就能B.A.method()这样去使用了，相当于在A的前面加了一个限定符，避免A放在外面时，被其他类所依赖。同时，在外部类没有初始化时，同样可以初始化静态内部类，如上面的做法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2020/07/25/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2020/07/25/she-ji-mo-shi-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h1><p>因为前段时间在公司项目中一个场景下需要用到观察者模式，所以在此做一个记录。</p><p>我遇到的问题是，在一个参数设置页面设置参数后，需要其它依赖这个参数的对象同时更新这些参数，如果采用后者不断去轮询的方式，一来消耗性能，二来也不能保证得到及时的更新，所以考虑使用观察者模式。</p><p>观察者模式(<em>Observer Pattern</em>)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。<br>观察者模式是一种对象行为型模式。<br>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>观察者模式中有“观察者” 和 “被观察者”，举个例子，微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是<em>被观察者<em>，而用户就是</em>观察者</em></p><p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p><p><img src="https://ae03.alicdn.com/kf/U1cffe803ca594bc7891c087dbcb28682c.png" alt="1"><br><img src="https://ae04.alicdn.com/kf/Udb3f3bbee22d4e5096b87aafaffdb4cfX.png" alt="2"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="Subject（目标）"><a href="#Subject（目标）" class="headerlink" title="Subject（目标）"></a>Subject（目标）</h4><p>被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p><h4 id="ConcreteSubject（具体目标）："><a href="#ConcreteSubject（具体目标）：" class="headerlink" title="ConcreteSubject（具体目标）："></a>ConcreteSubject（具体目标）：</h4><p>具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p><h4 id="Observer（观察者）："><a href="#Observer（观察者）：" class="headerlink" title="Observer（观察者）："></a>Observer（观察者）：</h4><p>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。<br>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update()方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>定义观察者接口</li></ol><pre><code>    interface Observer {        public void update();`    }</code></pre><ol start="2"><li>定义被观察者</li></ol><pre><code>abstract class Subject {    private Vector&lt;Observer&gt; obs = new Vector();    public void addObserver(Observer obs){        this.obs.add(obs);    }    public void delObserver(Observer obs){        this.obs.remove(obs);    }    protected void notifyObserver(){        for(Observer o: obs){            o.update();        }    }    public abstract void doSomething();}</code></pre><ol start="3"><li><p>具体的被观察者</p><pre><code>class ConcreteSubject extends Subject { public void doSomething(){     System.out.println("被观察者事件发生改变");     this.notifyObserver(); }}</code></pre></li><li><p>具体的被观察者</p><pre><code>class ConcreteObserver1 implements Observer { public void update() {     System.out.println("观察者1收到信息，并进行处理"); }}class ConcreteObserver2 implements Observer { public void update() {     System.out.println("观察者2收到信息，并进行处理"); }}</code></pre></li><li><p>客户端</p><pre><code>public class Client { public static void main(String[] args){     Subject sub = new ConcreteSubject();     sub.addObserver(new ConcreteObserver1()); //添加观察者1     sub.addObserver(new ConcreteObserver2()); //添加观察者2     sub.doSomething(); }}</code></pre></li></ol><p>输出</p><p><em>被观察者事件发生改变</em></p><p><em>观察者1收到信息，并进行处理</em></p><p><em>观察者2收到信息，并进行处理复制代码</em></p><p>通过运行结果可以看到，我们只调用了 Subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 Subject 类中关联一下 Observer 类，并且在 doSomething() 方法中遍历一下 Observer 的 update() 方法就行了。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系<br>目标与观察者之间建立了一套触发机制<br>支持广播通信<br>符合“开闭原则”的要求</p><p><strong>缺点</strong></p><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用<br>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</p><p><strong>应用</strong></p><p>JDK中的观察者模式<br>观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持，但在 Java9 被弃用了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷老师STL-听课笔记</title>
      <link href="/2020/07/01/hou-jie-lao-shi-stl-ting-ke-bi-ji/"/>
      <url>/2020/07/01/hou-jie-lao-shi-stl-ting-ke-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="侯捷老师STL-听课笔记"><a href="#侯捷老师STL-听课笔记" class="headerlink" title="侯捷老师STL-听课笔记"></a>侯捷老师STL-听课笔记</h1><p>1.binary_search使用时必须为有序容器</p><p>2.find算法使用时，如果没有查到目标元素，返回值的迭代器是b.end()，因为它是从头逐个开始查找的，所以如果没有目标值，就会一直走到容器尾部。</p><p>3.如果使用的算法涉及自定义类型对象的比较或者查找，需要在自定义类中重载＝＝号。如果参数是需要传入的是仿函数，则定义一个仿函数重载()，注意区分这两种情况，主要是要看算法的参数类型。</p><p>4.random_shuffle默认每次打乱后的结果是一样的，如果要实现每次打乱的结果不一样，则需要设置随机种子，导入<ctime>，srand（（unsigned int）time（NULL））。</ctime></p><p>5.Set_union,set_intersection,set_difference(差集)所传入的容器需要是有序的，并且返回值需要一个迭代器接受，这个迭代器指向输出结果的尾部。对于输出结果的存放，先要定义一个空间足够的容器，容器的起始地址作为参数。</p><p>6.构造函数与析构函数都是不继承的，子类中会重新生成默认的构造函数，在继承时，子类的构造函数的调用顺叙为，如果继承多个类，1 按照继承顺叙从左到右的顺叙依次调用父类的构造函数；2 类成员变量中有继承自父类的，按顺叙调用父类的构造函数（继承自父类的成员变量要调用父类的构造函数进行初始化）；3 调用本类自己的构造函数</p><p>7.为什么list容器不能像vector，deque那样使用algorithm的sort算法？？（9）</p><p>源码： 是因为list底层是用链表实现的，他的指针（迭代器）不能支持随机访问，而algorithm库里的sort函数需要下图红字的操作</p><p><img src="https://pic.rmb.bdstatic.com/bjh/a8297ea85a77919d3923e1a8f874c396.png" alt="图片1.png"></p><p>8.Deque在需要扩容时是如何实现的？与vector有何不同（两倍扩容）？</p><p>Deque是在内存上是分段连续的，扩容的时候是首位位置增加一个新的连续片段</p><p>9.分配器的实现，需要的参数（p是指针，1是分配的空间个数）</p><p><img src="https://ae01.alicdn.com/kf/Hb808568ca9f74351bc83dd8e6f41cddfU.png" alt="image.png"></p><p>10.Oop面向对象是为了实现数据和方法的组合，而泛型编程则是把数据和方法实现分离。</p><p>11.泛化，特化，偏特化。<br>泛化可以适用于不同的类型，但是可能对于某些特定的类型，函数要用不同的实现方式，这个时候可以对特定类型，模板可以做特化（明确原来模板的所有类型），偏特化则是明确部分类型。注意三者之间语法的不同。<br><img src="https://pic.rmb.bdstatic.com/bjh/812bec8d9d08567218eb33eb8c103ecc.png" alt="image.png"><br>源码中的特化例子</p><p><img src="https://ae03.alicdn.com/kf/H84a67b478db449cfa18a201a1edaf7c7W.png" alt="image.png"></p><p>偏特化例子</p><p><img src="https://ae04.alicdn.com/kf/H0e9d5db71c894eb7abde90ffd8368de7B.png" alt="image.png"></p><p>12.分配器 allocators</p><p>分配器其实在容器声明的时候可以指明，但一般没有必要，不声明的时候编译器会调用默认的。通过allocator对象调用Allocate 和 deallocate函数，而这两个函数是通过new函数和delete函数实现的，而new，delete函数都是通过调用malloc，free函数实现的。但是malloc函数在分配内存时，除了所用于存储数据的部分外，还有overhead部分，用来存储该内存块的信息，这部分也是会占不少空间的。所以当malloc较小内存的时候，该部分就会占较大的比例。<br><img src="https://pic.rmb.bdstatic.com/bjh/8ac022481ef4030ac59fc4214a6c31cb.png" alt="image.png"><br><img src="https://pic.rmb.bdstatic.com/bjh/0497efe8587c4a3107a44da814cec6a1.png" alt="image.png"></p><p><img src="https://ae03.alicdn.com/kf/Hb075b4074f9d45d08a6339cb9e889d120.png" alt="image.png"></p><p>13.容器的结构与分类</p><p><img src="https://ae02.alicdn.com/kf/Hadb8549876d8474a8ab9c463744170c6h.png" alt="image.png"><br><img src="https://ae01.alicdn.com/kf/Hae6104aabdf9403b8c35a170acb23dadL.png" alt="image.png"></p><p>14.深入理解list</p><p>List是用双向循环链表实现的，为了表示出容器的左开右闭的特性，end（）迭代器指向的尾部是一个空节点。每种容器都有自己的iterator实现，它们的iterator都会自己typedef五个类型，并且重载<em>，-&gt;，++（前），（后）++等操作符。比如list的</em>号重载是要返回当前节点的data，而前++与后++的重载也要注意，由于是链表，所以++操作的时候是返回下一个节点的指针，而不是像连续区间那样直接往后移动一个单位。<br>另外，对于++操作，前++是可以连续操作的，比如++（++i），所以返回值需要是原来对象的引用，而i++++是不被允许的，所以返回值就不能是该对象的引用。另外，重载++符号的时候，由于无法区分前++和后++，所以重载前++的时候，在添加一个“int”作为占位参数来区分。见下图的红色圈出部分。每个节点的前后指针都要占4或者8个字节，这在使用容器的时候要有意识。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/df36cb11be4134c94d43b04575861756.png" alt="image.png"><br><img src="https://ae04.alicdn.com/kf/H3b639cc3f7e34fdca7278963e0662a09q.png" alt="image.png"><br><img src="https://ae02.alicdn.com/kf/H6e74cfbd68d946b4855fef06a9c42ded1.png" alt="image.png"></p><p>15.Iterator作为容器与算法之间连接的桥梁，定义在每一种容器的内部，指针可以看作是一种退化的迭代器。因为数据与算法分离，算法需要知道容器的数据类型，迭代器类型，以及步长限制（迭代器能+1还是可以+任意值），这些都要通过迭代器获取。但是传给算法的迭代器有可能是退化的iterator，也就是指针，而指针是不能提供上述信息的，所以需要一个trait（特征的意思），萃取器，把是指针的迭代器过滤掉。<br><img src="https://ae03.alicdn.com/kf/Hc9a219c11201412aa3700ff289e093dfc.png" alt="image.png"><br><img src="https://pic.rmb.bdstatic.com/bjh/6b02e5a7fcab870edad749f7faeb3976.png" alt="image.png"></p><p>10 vector详解</p><p>Vector可以看作是一个可扩充的数组，每次扩容是按两倍扩容，如果原来的空间是0的话，第一次扩容则是变为1，没有扩容是在原来空间上进行的，都需要另行开辟空间。vector中维护三个指针，start，finish，end_of_storage.如图，所以对一个vertor求sizeof的时候，大小应该是12.（注意不是说size（））。三个指针也用来计算实现capacity，size函数，注意对于连续存储的容器（包括deque），都是可以用中括号[ ]来随机访问的，比如下图中就有[ ]的重载。<br><img src="https://pic.rmb.bdstatic.com/bjh/7b1d92da84d70585281e7f75ebb63d13.png" alt="image.png"><br>16.Array 详解<br>Array是一个定长的数组，所以在定义一个array的时候需要指定数组长度，如果指定是0的话，源码中也会对此做判断，然后初始化的时候给出1个单位空间，见下图红色横线部分。Array的iterator是一个普通的指针，所以萃取器使用的也是上面那一部分。另外，array是没有构造函数和析构函数的，可以注意到它是一个struct。</p><p><img src="https://ae01.alicdn.com/kf/H26c16d554b064d4b98124404edf568dbs.png" alt="image.png"></p><p>17.Deque详解<br>Deque是分段连续的，分段是本质，连续是表象。它有一个控制中心，就是图中的map所示的部分，是用一个vector实现的，应为要实现动态的增加buffer段，需要用到vertor的扩容的特性。Vector中存储的是指针，指向各个不同的分段。而iterator中则存储了四个指针，分别指向数据段的当前数据，开始位置，结束位置和node，它指向所在段在vector中所对应的位置。当在查找段中的数据时，他会检测是否到了所在段的边缘，若已超过所在段的范围，则开始移动到vector中的下一个指针，到达下一个buffer，通过这样的方法实现模拟出了连续空间。扩容的时候，先开辟一个buffer的空间，然后在vector中新增一个指针，指向这个新增的buffer，从而实现双端扩容。从这里可以看出iterator是一中功能更加强大的指针。<br>所以可以说deque的连续性主要是通过它的iterator实现的。<br>当它扩容的时候，vector是两倍扩容的，为了方便deque的双端操作，所以在vertor进行原来的内容拷贝的时候，会把内容拷贝到新vector的中间位置，以便deque的双端扩容。<br>Deque的insert函数的实现，非常智能。如果是插入在首位位置，则直接调用push_back()或者push_front()函数，如果插入在中间，则先计算插入位置离头近还是离尾近，然后选择一个更近的方向，把元素往前移动，然后再插入相应位置。<br><img src="https://ae01.alicdn.com/kf/Hed2a99abc7da4929b3bf6d0d6b438b9da.png" alt="image.png"><br><img src="https://ae02.alicdn.com/kf/H2bb7b1b5854e4fa68845765ec1d483f3q.png" alt="image.png"><br><img src="https://ae03.alicdn.com/kf/H98b237def20748da85597825e6d66daf1.png" alt="image.png"></p><p>18.Stack，queue详解</p><p>Stack和queue默认底层都是通过deque实现的，因为deque完全可以满足它们所需要的功能。这两种容器都不能遍历，也没有迭代器。Stack的pop函数就通过调用deque的pop_back()函数。queue的相应函数也是通过调用deque的函数实现的。<br>所以相应的，其实stack和queue也可以用list作为它的底层。<br>Stack可以用vector作为他的底层，但是queue不可以，原因时vector无法提供pop_front函数。同理，这两种容器也不能使用map或者set作为他的底层。</p><p><img src="https://ae01.alicdn.com/kf/H669e55b578004ce49c626dbd08087c07D.png" alt="image.png"><br><img src="https://ae01.alicdn.com/kf/H3d6ddba015f14d0aa81aa4d67f612c76u.png" alt="image.png"><br><img src="https://ae03.alicdn.com/kf/H332e4e195f884a3886c1dd45f4a7b7dcu.png" alt="image.png"><br><img src="https://ae04.alicdn.com/kf/H67ad2cf002344229bd4591f89efd58b6n.png" alt="image.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap 简介</title>
      <link href="/2020/06/22/linkedhashmap-jian-jie/"/>
      <url>/2020/06/22/linkedhashmap-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedHashMap-简介"><a href="#LinkedHashMap-简介" class="headerlink" title="LinkedHashMap 简介"></a>LinkedHashMap 简介</h1><p>平时使用过程中，一直以HashMap居多，或者需要排序的话，会选择TreeMap. 但有时候，既需要hashmap映射的特性，同时又想保持数据放入的先后顺序（其实可以理解为希望hashmap能记忆它put时候的先后次序，带上了时间信息）。这时候，LinkedHashMap就是较好的选择了。</p><p>LinekedHashMap之所以能做到这样，在于它多了两个指向前后元素的指针，这样便在元素之间维持了一个双向链表，使得元素的顺序可知了。结构大致如下：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/003634e34122761c6d674d414a2a51d0.png" alt="image.png"></p><p>从图中可以看出，多出了元素之间的前后指针，以及head，tail两个节点的定义（节点并没有增加，只是给他们取了个名字而已）。</p><p>看源码：</p><pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;{  static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {    Entry&lt;K,V&gt; before, after;    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {        super(hash, key, value, next);    }    // 双向链表头节点    transient LinkedHashMap.Entry&lt;K,V&gt; head;    // 双向链表尾节点    transient LinkedHashMap.Entry&lt;K,V&gt; tail;    final boolean accessOrder;  }}</code></pre><p>其中accessOrder这个变量指定遍历LinkedHashMap的顺序,true表示按照访问顺序,false表示按照插入顺序，默认为false。</p><p>从它的构造函数可以看出来这一点：</p><pre><code>   public LinkedHashMap(int initialCapacity, float loadFactor) {        super(initialCapacity, loadFactor);        accessOrder = false;    }</code></pre><p>也就是说，可以通过这个变量去设置自己需要的遍历顺序，下面用LinkeHashMap实现LRU即是利用了这一点。那刚刚说的“按访问顺序”是什么意思呢？看下面这个例子：</p><pre><code>LinkedHashMap&lt;Integer,Integer&gt; map = new LinkedHashMap&lt;&gt;(8, 0.75f, true);ap.put(1, 1);map.put(2, 2);map.put(3, 3);map.get(2);System.out.println(map);</code></pre><p>output；</p><pre><code>{1=1, 3=3, 2=2}</code></pre><p>也就是说，它把最近访问过的节点放倒了tail的位置，那么可以理解为，head位置的节点就是最久没有被访问的。那么它是怎么知道该把这个最近访问的节点放到tail位置的呢？从源码中寻找答案：</p><pre><code>    void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last        LinkedHashMap.Entry&lt;K,V&gt; last;        if (accessOrder &amp;&amp; (last = tail) != e) {            ...            ...            ...        }</code></pre><p>“move node to last”这句是源码中的注释，并不是我自己加的，也就是说正是这个函数实现了最近访问节点到tail的功能。此外，还有一个afterNodeInsertion方法，，其中，evict如果为false，则表处于创建模式,当我们new HashMap(Map map)的时候就处于创建模式，在下面的if语句中， removeEldestEntry 总是返回false,所以if的代码不会执行。</p><pre><code>    void afterNodeInsertion(boolean evict) { // possibly remove eldest        LinkedHashMap.Entry&lt;K,V&gt; first;        if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {            K key = first.key;            removeNode(hash(key), key, null, false, true);        }    }</code></pre><p>但我们正可以利用removeEldestEntry这个方法，实现一个简易版的LRU。代码如下：</p><pre><code>public class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; {  private int cacheSize;  public LRUCache(int cacheSize) {      super(16,0.75f,true);      this.cacheSize = cacheSize;  }  /**   * 判断元素个数是否超过缓存容量   */  @Override  protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {      return size() &gt; cacheSize;  }}</code></pre><p>当满足条件时，就删除head节点，而最近访问的节点则在tail位置。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带图片的toast的实现</title>
      <link href="/2020/06/12/dai-tu-pian-de-toast-de-shi-xian/"/>
      <url>/2020/06/12/dai-tu-pian-de-toast-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="带图片toast的实现"><a href="#带图片toast的实现" class="headerlink" title="带图片toast的实现"></a>带图片toast的实现</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近刚开始接触Android开发，算是进入了到了一个新领域。对于一个门外汉来讲，再简单的知识对他而言也是全新的。闻道有先后，术业有专攻，如是而已。这次介绍一下用到的带图片的toast的实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以自己创建一个ToastUtil类，提供showToast方法，在需要的时候调用即可。</p><pre><code>import android.content.Context;import android.view.Display;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.bilibili.bletester.R;public class ToastUtil extends Toast {    private static Toast mToast;    public ToastUtil(Context context) {        super(context);    }    public static void showToast(Context context, String content){    //获取系统的LayoutInflater        LayoutInflater inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);        View view = inflater.inflate(R.layout.toast_layout,null);        TextView tv_content = view.findViewById(R.id.tv_content);        tv_content.setText(content);        //实例化toast        mToast = new Toast(context);        mToast.setView(view);        mToast.setDuration(Toast.LENGTH_SHORT);    //这里可以设置toast默认显示的位置，当不进行设置时，则默认显示在屏幕下方       // mToast.setGravity(Gravity.BOTTOM,);        //mToast.setGravity(Gravity.BOTTOM,0,100);        mToast.show();    }}</code></pre><p>同时，在drawable中添加要显示的图片，注意添加图片不要太大，自己调试到合适尺寸，<br>如本例中添加了wetchat.jpg图片</p><p><img src="https://pic.rmb.bdstatic.com/bjh/22c1a0811abcaad1fccb7f60a147f520.png" alt="image.png"></p><p>在layout包下添加toast_layout.xml文件，内容如下</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:orientation="vertical"&gt;    &lt;ImageView        android:id="@+id/imageView"        android:layout_width="100dp"        android:layout_height="100dp"        android:layout_marginBottom="10dp"        android:scaleType="fitCenter"        app:srcCompat="@drawable/wechat" /&gt;    &lt;TextView        android:id="@+id/tv_content"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:gravity="center"        android:paddingLeft="18dp"        android:paddingTop="11dp"        android:paddingRight="18dp"        android:paddingBottom="11dp"        android:text="提醒成功"        android:textColor="?attr/colorAccent"        android:textSize="16sp" /&gt;&lt;/LinearLayout&gt;</code></pre><p>添加图片的关键在于中间的ImageView字段，配置图片与文字呈上下显示的字段是<br>android:orientation=”vertical”&gt;，<br>接下来进行测试，我在mainActivity.java中定义了如下函数：</p><pre><code>//测试ToastUtil类public void toast_test(View view){    ToastUtil.showToast(this,"lalala");}</code></pre><p>然后在activity_main.xml中添加如下一个按钮，即可实现调用了</p><pre><code>&lt;Button    android:id="@+id/button"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="Button"    android:onClick="toast_test"    app:layout_constraintBottom_toTopOf="@+id/textView"    app:layout_constraintEnd_toEndOf="parent"    app:layout_constraintStart_toStartOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;</code></pre><p>测试结果如下：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/9efe6df56e8b5913b17846ac83477758.png" alt="image.png"></p><p>其中server和client两个button是做其他用的，和这里的功能无关</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何一步步搭建SSM框架</title>
      <link href="/2020/06/03/ru-he-yi-bu-bu-da-jian-ssm-kuang-jia/"/>
      <url>/2020/06/03/ru-he-yi-bu-bu-da-jian-ssm-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="如何一步步搭建SSM框架"><a href="#如何一步步搭建SSM框架" class="headerlink" title="如何一步步搭建SSM框架"></a>如何一步步搭建SSM框架</h1><h2 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h2><ul><li>apache-tomcat</li><li>apache-maven </li><li>MySQL </li><li>Java jdk </li><li>IntelliJ IDEA</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>搭建框架可以考虑三个部分先单独配置，测试通过后再进行整合Spring-&gt;springMVC-&gt;Mybatis，再由spring分别整合springMVC和Mybatis，spring作为一个贯穿的部分。即要在springmvc中能使用spring的service,同时spring也管理Mybatis的代理对象，这样三个框架即得到了整合。以下为一个全过程。</p><h4 id="1-首先要创建相应的数据库和表，在数据库中创建名为“ssm”的database，注意其编码要设置为utf8，在数据库中创建一个名为“account”的表。代码如下："><a href="#1-首先要创建相应的数据库和表，在数据库中创建名为“ssm”的database，注意其编码要设置为utf8，在数据库中创建一个名为“account”的表。代码如下：" class="headerlink" title="1. 首先要创建相应的数据库和表，在数据库中创建名为“ssm”的database，注意其编码要设置为utf8，在数据库中创建一个名为“account”的表。代码如下："></a>1. 首先要创建相应的数据库和表，在数据库中创建名为“ssm”的database，注意其编码要设置为utf8，在数据库中创建一个名为“account”的表。代码如下：</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/fead6b7cac5fe9c4dfe02f990cee46aa.png" alt="image.png"></p><pre><code>create database ssm; use ssm; create table account( id int primary key auto_increment, name varchar(20), money double )ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><h2 id="创建project"><a href="#创建project" class="headerlink" title="创建project"></a>创建project</h2><h4 id="1-建立一个空project（不是空的应该也没关系）"><a href="#1-建立一个空project（不是空的应该也没关系）" class="headerlink" title="1. 建立一个空project（不是空的应该也没关系）"></a>1. 建立一个空project（不是空的应该也没关系）</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/27fd2e409caf09d66040deaf2613eaec.png" alt="image.png"></p><h4 id="2-选中file-gt-new-建立一个新的module-框架即搭建在这个module中，其中SDK选择自己安装的那个"><a href="#2-选中file-gt-new-建立一个新的module-框架即搭建在这个module中，其中SDK选择自己安装的那个" class="headerlink" title="2. 选中file->new,建立一个新的module,框架即搭建在这个module中，其中SDK选择自己安装的那个"></a>2. 选中file-&gt;new,建立一个新的module,框架即搭建在这个module中，其中SDK选择自己安装的那个</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/14ded4b6773ea40b6560d64d41b2a9e6.png" alt="image.png"></p><p>对moudle进行命名和存放位置，注意父工程要设为none</p><p><img src="https://pic.rmb.bdstatic.com/bjh/90ebcf3492a73b3d63bbf9e824934950.png" alt="image.png"></p><p>选择自己maven安装的路径，不要用默认的，另外“user settings files”也要用自己安装的meven路径下的配置文件，同时注意local repository是否也是自己配置的文件夹。<br>解决maven创建过慢的问题，在添加Name：archetypeCatalog  Value：internal这一键值对，然后finish。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/da1f0a2171d4ba436996d2e4a7f5739f.png" alt="image.png"></p><h4 id="3-接下到来在pom-xml中导入依赖坐标，将下面的部分代替原来pom-xml中的对应部分，"><a href="#3-接下到来在pom-xml中导入依赖坐标，将下面的部分代替原来pom-xml中的对应部分，" class="headerlink" title="3. 接下到来在pom.xml中导入依赖坐标，将下面的部分代替原来pom.xml中的对应部分，"></a>3. 接下到来在pom.xml中导入依赖坐标，将下面的部分代替原来pom.xml中的对应部分，</h4><pre><code>  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;    &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;    &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;    &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;    &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;!-- spring --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;      &lt;version&gt;1.6.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;${mysql.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;      &lt;version&gt;2.5&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.0&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;jstl&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- log start --&gt;    &lt;dependency&gt;      &lt;groupId&gt;log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j&lt;/artifactId&gt;      &lt;version&gt;${log4j.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;      &lt;version&gt;${slf4j.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;      &lt;version&gt;${slf4j.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- log end --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;${mybatis.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;1.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;c3p0&lt;/groupId&gt;      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;      &lt;version&gt;0.9.1.2&lt;/version&gt;      &lt;type&gt;jar&lt;/type&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;ssm&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.7.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.20.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p>导入之后，要等待其对jar包进行import，在下面这个文件夹中可以看到依赖的包</p><p><img src="https://pic.rmb.bdstatic.com/bjh/82423d3666ef2d3791e9f1d660c8dff7.png" alt="image.png"></p><p>建立相应包，在main目录下先建立两个文件夹，java和resources，并分别设为source root 和 resources root，java用来存放各个模块（如dao，service，controller）的源代码.java文件，而resources目录则存放配置文件，如spring的配置文件（applicationContext.xml）,springmvc的配置文件等等</p><p><img src="https://pic.rmb.bdstatic.com/bjh/dd5f2834122d87e57b53dedde8487a24.png" alt="image.png"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/bbba003c3d954e2f11aba62fba5cecca.png" alt="image.png"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/314d7fd458ec080837639a45f769f470.png" alt="image.png"></p><h4 id="4-在java文件夹下新建"><a href="#4-在java文件夹下新建" class="headerlink" title="4. 在java文件夹下新建"></a>4. 在java文件夹下新建</h4><pre><code>guang.fram.dao: 存放数据访问层的接口guang.fram.domain: 存放资源类的bean，比如此例子中定义一个account类，并且定义getter，setter方法）, guang.fram.controller: 定义控制层的接口和方法guang.fram.service: 服务层guang.fram.test: 这是一个测试包，用来测试上面这些包中的方法及配置能否正常工作</code></pre><p>接下来开始创建接口和类<br>在guang.fram.domain定义一个account.java类<br>代码：</p><pre><code>package guang.fram.domain;import java.io.Serializable;/** * 帐户,在domain中构建java bean,即写一个类，类的属性与数据库表中的一些属性对应 * 并且生成相应的getter 和 setter方法，然后再到dao层去写操作bean数据的接口 */public class Account implements Serializable{    private Integer id;    private String name;    private Double money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Double getMoney() {        return money;    }    public void setMoney(Double money) {        this.money = money;    }    @Override    public String toString() {        return "Account{" +                "id=" + id +                ", name='" + name + '\'' +                ", money=" + money +                '}';    }}</code></pre><p>然后在dao包中定义一个AccountDao的接口，因为对于Mybatis来说，只要给他提供接口就行了，所以接口中提供要进行的数据操作即可，这里定义两个方法，一个是查询数据的findAll方法，一个是保存数据的save方法，代码如下：</p><pre><code>/** 此处写操作account bean 的接口，写两个方法，1. 获取所有账户* 2. 保存账户信息* 此处只需要写接口，因为对于mybatis，只要提供接口就可以了* 然后在service层中要写对account的业务操作的接口，AccountService* 该接口中也是以下的两个方法，但是在serveic包中还需要一个impl包，该* 包中定义一个类实现以下两个方法** */package guang.fram.dao;import guang.fram.domain.Account;import java.util.List;public interface AccountDao {     //获取所有账户public List&lt;Account&gt; findAll();    //保存账户信息    public void save(Account account);}</code></pre><p>然后到service包里边定义接口和实现类，实现类放在service下的专门新建的一个Impl包中<br>先在service中新建一个AccountService接口，里边的方法也就是上面dao接口里边的两个方法，代码如下：</p><pre><code>package guang.fram.service;import guang.fram.domain.Account;import java.util.List;public interface AccountService {    public List&lt;Account&gt; findAll();    public void save(Account account);}</code></pre><p>然后service下新建一个Impl包<br>Impl包中定义实现类AccountServiceImpl，实现刚刚定义的接口，这里先做一个简单的输出作为实现，后面整合其它模块后再补充代码：</p><pre><code>/** 这个类实现serveic层中定义的接口accountServce，* 这两个方法在dao层中即有声明* 接下来还要在controller层中定义相应类** * */package guang.fram.service.Impl;import guang.fram.domain.Account;import guang.fram.service.AccountService;import java.util.List;public class AccountServiceImpl implements AccountService {    @Override    public List&lt;Account&gt; findAll() {        System.out.println("业务层在查询所有账户信息");        return null;    }    @Override    public void save(Account account) {        System.out.println("业务层在保存账户信息");    }}</code></pre><p>接下来还要在controller层中定义相应类AccounController</p><pre><code>//web层package guang.fram.controller;public class AccountController {}</code></pre><p>至此，三个部分的相应包建立好了，要整合三个模块，由于是spring分别整合springmvc和mybatis，所以先要配置spring，将对象交给spring的ioc进行管理。</p><h2 id="配置spring"><a href="#配置spring" class="headerlink" title="配置spring"></a>配置spring</h2><h4 id="1-要配置spring，就要在resources目录下新建一个配置文件，可以取名“applicationContext-xml”，新建方法和配置内容如下："><a href="#1-要配置spring，就要在resources目录下新建一个配置文件，可以取名“applicationContext-xml”，新建方法和配置内容如下：" class="headerlink" title="1. 要配置spring，就要在resources目录下新建一个配置文件，可以取名“applicationContext.xml”，新建方法和配置内容如下："></a>1. 要配置spring，就要在resources目录下新建一个配置文件，可以取名“applicationContext.xml”，新建方法和配置内容如下：</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/558f3c3f8ba884d146caa8dee66bc332.png" alt="image.png"></p><p>新建时，可能会出现没有“spring config”那个选项，解决办法：</p><p>配置文件内容如下：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:tx="http://www.springframework.org/schema/tx"       xsi:schemaLocation="http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop.xsd   http://www.springframework.org/schema/tx   http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;    &lt;!--开启注解的扫描,但是只希望spring扫描dao层    和service的注解，controller的注解由springMVC来负责，所以需要exclude掉有controller的注解--&gt;    &lt;context:component-scan base-package="guang.fram"&gt;        &lt;!--配置不需要spring扫描的注解--&gt;        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;    &lt;/context:component-scan&gt;&lt;/beans&gt;</code></pre><p>配置好之后，就可以使用注解来使用对象了，所以在AccountServiceImpl这个类前加service注解了<br>代码变成：</p><pre><code>package guang.fram.service.Impl;import guang.fram.domain.Account;import guang.fram.service.AccountService;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImpl implements AccountService {    @Override    public List&lt;Account&gt; findAll() {        System.out.println("业务层在查询所有账户信息");        return null;    }    @Override    public void save(Account account) {        System.out.println("业务层在保存账户信息");    }}</code></pre><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>接下来可在test包下新建TestSpring类来进行测试，测试代码如下，注意在这里使用test的注解，需要在pom.xml中配置juint的scope为compile，而不是test，具体请见pom.xml的相关配置：</p><pre><code>package guang.fram.test;import guang.fram.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring {    @Test    public void run1(){        /*         * 使用spring的步骤         * */        //加载配置文件ApplicationContext ac = new ClassPathXmlApplicationContext( "classpath:applicationContext.xml" );        //获取对象,(获取的对象需要强转为相应的类型)        AccountService as = (AccountService) ac.getBean("accountService");        //调用方法        as.findAll();    }}</code></pre><p>然后点run，运行结果如下：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/a83590889270f429a5cfc793afe50517.png" alt="image.png"></p><p>可见被正常调用，但上面有两个warning;</p><pre><code>log4j:WARN No appenders could be found for logger ( org. springframework. core. env. StandardEnvironment).log4j:WARN Please initialize the log4j system properly.</code></pre><p>原因是log4j这个包的配置文件没有放到resoources包下，把log4j.properties文件粘到该包下即可。一般需要重启idea才生效。<br>到这一步时，目录已变成如下样子：</p><p> <img src="https://pic.rmb.bdstatic.com/bjh/eda6362c0c8c0de4021fade2a262df9f.png" alt="image.png"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/25974b8afac7e99e70fc4dc455f4a696.png" alt="image.png"></p><p><strong>至此，单独的spring已经可以正常工作，接下来考虑配置springmvc以及整合spring和springmvc</strong></p><h2 id="配置SpringMVC"><a href="#配置SpringMVC" class="headerlink" title="配置SpringMVC"></a>配置SpringMVC</h2><p>Web的配置在webapp\WEB-INF\web.xml文件中，web-inf这个目录是web的内部访问的目录，浏览器是无法访问到里面的资源的，web.xml则用来写web项目的配置文件，在里面需要配置前端控制器，过滤器（解决中文乱码问题）以及加载springmvc的配置文件。注意，web.xml书写的内容，各个部分是要遵循一定顺叙的，否则会报错，比如filter在第二个部分，代码如下：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--解决中文乱码的问题，设置过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;!--设定编码集--&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;!--设置该字符过滤器要拦截的内容--&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;!--表示所有的内容都被此过滤器拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--这里是配置前端控制器--&gt;  &lt;!--希望做的是 1.加载springMVC.xml配置文件  &lt;                1. 启动服务器，就创建该servlet--&gt; &lt;servlet&gt;   &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;   &lt;!--加载springMVC配置文件，springMVC.xml配置文件在resources目录下进行创建，   创建的方法是：右键resources-&gt;new-&gt;选择xml configuration File-&gt;选择Spring config-&gt;命名为springMVC.xml--&gt;   &lt;init-param&gt;     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;     &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;   &lt;/init-param&gt;   &lt;!--启动服务器，创建该servlet--&gt;   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>此时，需要在resources目录下再创建一个springMVC.xml的配置文件，创建方法与applicationContext.xml的方法相同。<br>接下来配置springmvc.xml的内容，一共分为四部分：</p><ol><li>开启注解扫描。只扫描是Controller的注解（注意与spring的xml的配置对应）</li><li>配置视图解析器对象</li><li>过滤静态资源（即静态资源不进行拦截</li><li>开启springMVC注解的支持</li></ol><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!--开启注解扫描。只扫描是Controller的注解,所以用include（注意与spring的xml的配置对应）--&gt;    &lt;context:component-scan base-package="guang.fram"&gt;        &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;    &lt;/context:component-scan&gt;    &lt;!--配置视图解析器对象--&gt;    &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;            &lt;!--配置前缀和后缀--&gt;        &lt;!--web-info的pages目录下的文件，所以需要在WEB-INF下新建pages文件夹--&gt;        &lt;property name="prefix" value="/WEB-INF/pages/"/&gt;        &lt;!--后缀名为.jsp的文件--&gt;        &lt;property name="suffix" value=".jsp"/&gt;    &lt;/bean&gt;    &lt;!--过滤静态资源（即静态资源不进行拦截？？）--&gt;    &lt;mvc:resources location="/css/" mapping="/css/**" /&gt;    &lt;mvc:resources location="/images/" mapping="/images/**" /&gt;    &lt;mvc:resources location="/js/" mapping="/js/**" /&gt;    &lt;!--开启springMVC注解的支持--&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;</code></pre><p>此时，需要在WEB-INF目录下新建pages文件夹，用来存放静态资源等，同时删除原来的index.jsp,再右键，创建一个新的jsp文件，仍然命名为index.jsp，该页面是启动服务器之后，浏览器自动打开的页面。index.jsp内容如下：</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: guang  Date: 2020/4/21  Time: 16:32  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;%--先delete掉原来的index.jsp文件，然后new一个--%&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--href后的account为一级目录，findAll为标签定义好此标签后，然后到controller包下的AccountController方法中定义findAll方法--%&gt;&lt;a href="account/findAll"&gt;测试测试测试测试查询数据的数据&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里的account/findAll，前面account是虚拟路径，findAll是资源路径，也即是servlet的路径，但是在springMVC里边用的是注解的形式。所以接下来修改在controller包下的AccountController类的内容，变成如下：</p><pre><code>package guang.fram.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** 账户web，运行这个类之前，先要配置好SpringMVC.xml文件* 以使得tomcat启动之后，相应的注解能够生效，同时index.jsp里面要提供请求找到此资源* 的href，下面的return返回值是跳转页面的文件名，这些跳转页面放在web-inf目录下的* 自建的pages文件夹中，并且要在springMVC.xml中配置视图解析器对象，即：* &lt;!--配置视图解析器对象--&gt;    &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;            &lt;!--配置前缀和后缀--&gt;        &lt;!--web-info的pages目录下的文件--&gt;        &lt;property name="prefix" value="/WEB-INF/pages/"/&gt;        &lt;!--后缀名为.jsp的文件--&gt;        &lt;property name="suffix" value=".jsp"/&gt;    &lt;/bean&gt;* 以使得它能根据目录找到文件* */@Controller@RequestMapping("/account")public class AccountController {    @RequestMapping("/findAll")    public String findAll() {        System.out.println("表现层在查询所有的账户信息");//controller把数据存到这个域对象里边去了，然后通过下面的return转发到list.jsp页面        //所以可以在该页面对list的数据做操作，比如遍历之类的        //下面这句话的意思是往webapp目录下的pages目录里的list.jsp页面跳转,        return "list";    }}</code></pre><p>由于要往pages文件夹下的list.jsp跳转，所以在该文件夹下新建list.jsp页面，内容如下：</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: guang  Date: 2020/4/24  Time: 15:16  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;查询了所有的账户信息，这是从AccountController类的findAll方法跳转来的&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>到这里之后，springMVC的单独配置基本完成，可以启动tomcat服务器测试一下，服务器启动和配置方法如下：</p><ol><li>选择右上角位置下拉菜单中的edit configurations</li></ol><p><img src="https://pic.rmb.bdstatic.com/bjh/5d660c4862a26cb1cd8d4f214c000459.png" alt="image.png"></p><ol start="2"><li>进入到了如下页面：</li></ol><p><img src="https://pic.rmb.bdstatic.com/bjh/9737984ea0a7c2a96e3803c7e6a4a0b1.png" alt="image.png"></p><ol start="3"><li>选择右侧的“+”号—&gt;选择Artifact，（如果打开里边本来就有项目在，则需要先移除掉，再添加）—-&gt;选择“ssm2:war exploded”,确认，此时不要选右下方的“OK”,而是切换到上方的“Server”那一栏，并按如下进行参数选择：</li></ol><p><img src="https://pic.rmb.bdstatic.com/bjh/4cfb568138b25c879e1ce7d7455dfd7d.png" alt="image.png"></p><ol start="4"><li>点击右下方”OK”，此时就可以点击idea上方的启动按钮，启动tomcat服务器，正常来说浏览器会自动跳转到如下页面：</li></ol><p><img src="https://pic.rmb.bdstatic.com/bjh/2a3e3007ae388c593929a24248a3abbf.png" alt="image.png"></p><p>点击该链接：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/09b67bf641230346e39fe94e1b483516.png" alt="image.png"></p><h2 id="Spring-与-SpringMVC的整合"><a href="#Spring-与-SpringMVC的整合" class="headerlink" title="Spring 与 SpringMVC的整合"></a>Spring 与 SpringMVC的整合</h2><p>spring再整合springMVC框架</p><pre><code>要整合spring与springMVC，即要在controller中也能使用spring中的service，构建bean对象，但是原来的单纯的springMVC的配置文件中，只配置了扫描Controller注解，而不会扫描service注解，所以即是要启动服务器时，同时加载spring与springmvc的配置文件。</code></pre><p>当启动tomcat服务器的时候，web.xml里面如果只配置了springMVC..xml文件，则只会加载springMVC的配置，而没有去扫描spring的配置文件。为了启动服务器时同时加载spring的配置文件，需要在web.xml中配置一个监听器，监听当启动服务器，创建了servletContext对象（域对象，只创建一次销毁一次，当服务器启动的时候，它被创建，当服务器关闭时，它被销毁）的时候，此时去加载spring的配置文件。</p><p>但还有个问题是该监听器默认只加载WEB-INF目录下的applicationContext.xml配置文件，而spring的配置文件放在了resources目录下，因此该listener找不到，所以还需要在web.xml中配置其路径。</p><p>所以，将原来的web.xml文件修改为如下，红色部分即新添内容，之所以放在不同位置，是因为要遵循web.xml的书写顺叙：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--配置路径，以使得监听器能去加载spring的配置文件applicationContext,配置好之后，就能在  AccountController类中使用依赖注入了--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--解决中文乱码的问题，设置过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;!--设定编码集--&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;!--设置该字符过滤器要拦截的内容--&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;!--表示所有的内容都被此过滤器拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--配置监听器，因为启动服务器后，加载web.xml文件，根据此文件加载springMVC的配置文件，而没有去加载spring的配置文件，  所以需要设置此监听器，当服务器启动开始加载servletContext对象时，也去加载spring的配置文件 但该监听器 默认只加载WEB-INF目录下的applicationContext.xml配置文件，所以下面还需要配置其路径  --&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--这里是配置前端控制器--&gt;  &lt;!--希望做的是 1.加载springMVC.xml配置文件  &lt;                2. 启动服务器，就创建该servlet--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--加载springMVC配置文件，springMVC.xml配置文件在resources目录下进行创建，    创建的方法是：右键resources-&gt;new-&gt;选择xml configuration File-&gt;选择Spring config-&gt;命名为springMVC.xml--&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--启动服务器，创建该servlet--&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>这样配置好之后，就能将controller和service都放入到容器中进行管理，也就是说在AccountController也能使用service的注解了。为了测试，在AccountController定义一个AccountService的对象，用autowired进行自动注入，AccountController类变成如下：</p><pre><code>package guang.fram.controller;import guang.fram.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("/account")public class AccountController {    @Autowired    private AccountService accountService;    @RequestMapping("/findAll")    public String findAll() {        System.out.println("表现层在查询所有的账户信息");        accountService.findAll();//这里调用的方法时service层里边的        //下面这句话的意思是往webapp目录下的pages目录里的list.jsp页面跳转,        return "list";    }}</code></pre><p>此时再启动服务器，当点击页面链接时，即会调用controller中的findAll方法，控制台会输出System.out.println(“表现层在查询所有的账户信息”); 而findAll方法中，又有accountService.findAll();它会调用到AccountService里的findAll方法，所以此时控制台应该输出两句话，如下：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/ae29cf787bb46f5183190425f3da91b3.png" alt="image.png"></p><p>说明在controller层中也能使用service层中的对象和方法了，spring和springMVC整合完毕。</p><h2 id="配置Mybatis"><a href="#配置Mybatis" class="headerlink" title="配置Mybatis"></a>配置Mybatis</h2><ol><li>先单独配置好mybatis，测试通过后再进行spring与mybatis的整合，由于mybatis可以使用注解的方式，所以现在只需要配置一个SqlMapConfig.xml的配置文件即可。先再AccountDao.java接口中写好sql的注解,变成如下：</li></ol><pre><code>package guang.fram.dao;import guang.fram.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import java.util.List;public interface AccountDao {        //获取所有账户        @Select("select * from account")        public List&lt;Account&gt; findAll();        //保存账户信息        @Insert("insert into account (name,money) value (#{name},#{money})")        public void saveAccount(Account account);    }</code></pre><ol start="2"><li>接下来在resources目录下创建配置文件SqlMapConfig.xml，右键resources–&gt;选择”file”–&gt;命名为：SqlMapConfig.xml。配置文件内容如下：</li></ol><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!--两大部分，1. 配置环境 2. 引入映射配置文件--&gt;    &lt;!-- 配置连接数据库的信息 --&gt;    &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt;    &lt;!--配置环境--&gt;    &lt;environments default="mysql"&gt;        &lt;environment id="mysql"&gt;            &lt;!-- 配置事务管理 --&gt;            &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="${jdbc.driver}"/&gt;                &lt;!--注意url这个属性是连接自己的数据库，所以在配置文件中是这个值：jdbc.url=jdbc:mysql://localhost:3306/ssm                上面地址3306后面是database的名字，此外，下面的${}这种形式的是通过配置文件读取相应值的方式，配置文件放在了resources目录下，文件名为：jdbcConfig.properties，但是url这个属性在ssm的后面需要添加?useUnicode=true&amp;amp;characterEncoding=utf8以解决传输时，出现中文乱码的问题--&gt;                &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8"/&gt;                &lt;property name="username" value="${jdbc.username}"/&gt;                &lt;property name="password" value="${jdbc.password}"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--引入映射配置文件，以使得mybatis能扫描到相应的注解，有两种方式，一直是把放了注解的相应类的全限定名    赋给class属性，第二种将该类所在的包名赋给package属性，这种方法可以将该包名下所有的注解都扫描到，相应方便一些    要注意两个路径开始的开始位置，取全限定名就没问题--&gt;    &lt;mappers&gt;        &lt;!--第一种方法        &lt;mapper class="guang.fram.dao.AccountDao"/&gt;        --&gt;        &lt;!--第二种方法，如果还有其他的包需要扫描，则可以继续添加到下面--&gt;        &lt;package name="guang.fram.dao"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><ol start="3"><li>接下来在test包中新建一个testMybatis类来测试mybatis是否配置成功，使用mybatis过程及代码如下：</li></ol><pre><code>package guang.fram.test;import guang.fram.dao.AccountDao;import guang.fram.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;/** 这个测试类用来测试mybatis的连接情况* */public class testMybatis {    //测试对数据库的查询操作    @Test    public void run1() throws Exception {      /*      * 步骤 1.加载配置文件      * 2.创建SqlSessionFactory对象      * 3.用工厂factory创建SqlSession对象      * 4.用工厂factory创建SqlSession对象      * 5.获取代理对象      * 6.用此代理对象可以操作相应接口中（AccountDao）的所有方法      * 7.关闭资源      *      * 以下使用的方法中有很多是重载的，要注意根据传入的参数进行选择      * */        //加载配置文件(定义Resources的时候选用org.apache.ibatis.io那一个),并将抛出的异常改为Exception        InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");        //创建SqlSessionFactory对象        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);        //用工厂factory创建SqlSession对象        SqlSession session = factory.openSession();        //获取代理对象        AccountDao dao = session.getMapper(AccountDao.class);        //用此代理对象可以操作相应接口中（AccountDao）的所有方法        List&lt;Account&gt; list = dao.findAll();        for(Account a : list) {            System.out.println(a);        }        //关闭资源        session.close();        in.close();    }    //测试对数据库的添加保存工作，注意，查询不需要提交事务，但增删改需要，即执行完后要session.commit();    @Test    public void run2() throws Exception {        InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);        SqlSession session = factory.openSession();        AccountDao dao = session.getMapper(AccountDao.class);        //用此代理对象可以操作相应接口中（AccountDao）的所有方法        Account ac = new Account();        ac.setName("崔八");        ac.setMoney(1000.0);        dao.saveAccount(ac);        //提交事务        session.commit();        //关闭资源        session.close();        in.close();    }}</code></pre><p>接下来运行run1函数，结果如下，其中的”??”并不是出现了乱码，而是数据库中本来存储的就是”??”：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/fac72848a102427d7ef0099d5fc1b8c7.png" alt="image.png"></p><h2 id="整合spring与mybatis"><a href="#整合spring与mybatis" class="headerlink" title="整合spring与mybatis"></a>整合spring与mybatis</h2><ol><li>Spring整合Mybatis</li></ol><p>即要在service里边能调用mybatis的对象，与整合springMVC的原理类似，spring可以将对象通过ioc进行管理，而mybatis是通过代理对象实现的，如果能把代理对象也放到spring中进行管理，然后通过注入进行使用，则可以实现spring与mybatis的整合了</p><pre><code>    &lt;!--spring整合mybatis框架--&gt;    &lt;!--spring整合mybatis框架，需要配置三个部分--&gt;    &lt;!--    1. 配置连接池    2.配置SqlSessionFactory工厂，因为通过工程能拿到session代理，有了代理能将    对象存到容器当中去管理    3. 配置AccountDao所在的包，因为要通过这些包，让spring知道创建哪些接口的对象    --&gt;    &lt;!--配置连接池--&gt;   &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;       &lt;!--配置四个属性--&gt;       &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;&lt;!--下面的url同样要注意在ssm的后面加上”?characterEncoding=utf8”,防止传输时出现中文乱码--&gt;       &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm?characterEncoding=utf8"/&gt;       &lt;property name="user" value="root"/&gt;       &lt;property name="password" value=""/&gt;   &lt;/bean&gt;    &lt;!--配置工厂--&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;    &lt;!--再引入上面常见的datasource--&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;    &lt;!--配置dao接口所在的包--&gt;    &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;        &lt;property name="basePackage" value="guang.fram.dao"/&gt;    &lt;/bean&gt;    &lt;!--配置好之后，可以删掉SqlMapConfig.xml了，然后在AccountDao.java的接口前面加上@Repository的注解--&gt;</code></pre><p>配置好之后，可以删掉SqlMapConfig.xml了（不删也不影响），然后在AccountDao.java的接口前面加上@Repository的注解，加上这个注解之后，意味着这个接口交给spring进行管理了，就可以到AccountServiceImpl里面注入这个接口并使用了。<br>AccountDao接口变成了如下：</p><pre><code>package guang.fram.dao;import guang.fram.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import java.util.List;/** 此处写操作account bean 的接口，写两个方法，1. 获取所有账户* 2. 保存账户信息* 此处只需要写接口，因为对于mybatis，只要提供接口就可以了* 然后在service层中要写对account的业务操作的接口，AccountService* 该接口中也是以下的两个方法，但是在serveic包中还需要一个impl包，该* 包中定义一个类实现以下两个方法** */@Repository//加上上面那个注解之后，就可以到AccountServiceImpl里面注入这个接口并使用了public interface AccountDao {    //获取所有账户    @Select("select * from account")    public List&lt;Account&gt; findAll();    //保存账户信息    @Insert("insert into account (name,money) value (#{name},#{money})")    public void saveAccount(Account account);}</code></pre><p>然后进入到AccoutServiceImpl.java这个类，进行注入并使用，因为之前该类中的findAll方法和save方法只是做了一个简单的输出，而现在那个类也可以使用mybatis的代理对象了，所以她的findAll方法就可以通过这个代理对象去实际的操作数据库，该类变成如下：</p><pre><code>package guang.fram.service.impl;import guang.fram.dao.AccountDao;import guang.fram.domain.Account;import guang.fram.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** 这个类实现serveic层中定义的接口accountServci，* 这两个方法在dao层中即有声明* 接下来还要在controller层中定义相应类** 这个service的类要交给spring的ioc进行管理，先要对resources目录下的配置文件配置spring进行注解的* 扫描* */@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    @Override    public List&lt;Account&gt; findAll() {        System.out.println("业务层在查询所有账户信息");        //return null;        //使用spring整合mybatis之后，通过ioc得到的accountDao来调用        return accountDao.findAll();    }    @Override    public void saveAccount(Account account) {        System.out.println("业务层在保存账户信息");        //使用spring整合mybatis之后，通过ioc得到的accountDao来调用        accountDao.saveAccount(account);    }}</code></pre><p>而AccountContorller.java也已经与spring整合好了，controller中的findAll方法又调用了service中的findAll方法，这样一来，相当于从contoller层操作到了数据库，而service的findAll的方法从数据库拿到的数据就返回给了controller，因此AccountController.java对该数据可以进行一下保存，并返回给list.jsp页面，list.jsp再可以对拿到的数据做个遍历显示出来。<br>AccountController.java修改成如下：</p><pre><code>package guang.fram.controller;import guang.fram.domain.Account;import guang.fram.service.AccountService;//import jdk.packager.internal.Module;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** 账户web，运行这个类之前，先要配置好SpringMVC.xml文件* 以使得tomcat启动之后，相应的注解能够生效，同时index.jsp里面要提供请求找到此资源* 的href，下面的return返回值是跳转页面的文件名，这些跳转页面放在web-inf目录下的* 自建的pages文件夹中，并且要在springMVC.xml中配置视图解析器对象，即：* * &lt;!--配置视图解析器对象--&gt;    &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;            &lt;!--配置前缀和后缀--&gt;        &lt;!--web-info的pages目录下的文件--&gt;        &lt;property name="prefix" value="/WEB-INF/pages/"/&gt;        &lt;!--后缀名为.jsp的文件--&gt;        &lt;property name="suffix" value=".jsp"/&gt;    &lt;/bean&gt;* 以使得它能根据目录找到文件* */@Controller@RequestMapping("/account")public class AccountController {    /*在web.xml中配置好监听器之后，就整合好了spring与springmvc，就可以在这个类中使用依赖注入了*/    @Autowired    private AccountService accountService;    @RequestMapping("/findAll")    public String findAll(Model model){        System.out.println("表现层在查询所有的账户信息");        //下面这个是使用了spring的依赖注入后生成的对象所调用的service里面的方法        List&lt;Account&gt; list = accountService.findAll();        //然后在上面的findAll的参数表里边用一个Moudel对象，将数据存入一个键值对里边        model.addAttribute("list",list);        //controller把数据存到这个域对象里边去了，然后通过下面的return转发到list.jsp页面        //所以可以在该页面对list的数据做操作，比如遍历之类的        //下面这句话的意思是往webapp目录下的pages目录里的list.jsp页面跳转,        return "list";    }    //页面提交的数据保存到数据库的功能    @RequestMapping("/save")    //从页面提交拿到的数据，要先封装，可以直接在参数列表中定义一个Account对象，会自动将传入的参数封装到此对象中    //然后直接使用spring管理的对象accountService直接调用save方法就可以了    public String save(Account account){        accountService.save(account);        return "list";    }}</code></pre><p>修改list.jsp页面为如下：</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: guang  Date: 2020/4/21  Time: 16:42  To change this template use File | Settings | File Templates.--%&gt;&lt;%--用El,所以下面这句最后要加上那一句--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%--引入jstl的标签库--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;表现层查询了所有的账户信息，这是从controller包下的AccountController类里的findAll方法跳转来的&lt;/h3&gt;&lt;%--对传过来的list进行迭代,items属性值的是要遍历的集合，var是给集合中变量的命名--%&gt;&lt;c:forEach items="${list}" var="account"&gt;${account.name}    ${account.money}&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>此时再次启动tomcat服务器，页面如下：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/2f5d9a1a61f8f74c302133db2b215430.png" alt="image.png"></p><p>点击链接后，跳转：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/6aba7cbc2238b2d2c4aa4fd5b74ae406.png" alt="image.png"></p><p>可见，通过上面的调用，AccountController拿到了数据库的数据。</p><h2 id="spring进行声明式事务管理"><a href="#spring进行声明式事务管理" class="headerlink" title="spring进行声明式事务管理"></a>spring进行声明式事务管理</h2><p>如果要实现对account数据的保存，则还需要在spring的配置文件applicationContext.xml中进行声明式事务管理<br>配置分三部分：</p><ol><li>配置事务管理器   </li><li>配置事务通知</li><li>配置AOP增强<br>在applicationContext.xml添加如下部分：</li></ol><pre><code>&lt;!--配置spring的声明式事务管理，因为要实现将页面提交的数据保存到数据库中，需要进行此配置--&gt;    &lt;!--配置分三部分：1.配置事务管理器   2. 配置事务通知   3. 配置AOP增强--&gt;    &lt;!--1.配置事务管理器--&gt;    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;        &lt;!--需要传入连接池这个引用--&gt;        &lt;property name="dataSource" ref="dataSource"/&gt;    &lt;/bean&gt;    &lt;!--2. 配置事务通知,将上面的事务管理器传进来--&gt;    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;        &lt;!--配置事务的属性，比如隔离级别，以及哪些方法配置事务通知--&gt;        &lt;tx:attributes&gt;            &lt;!--将带有find的方法设置为read-only级别--&gt;            &lt;tx:method name="find" read-only="true"/&gt;            &lt;!--将其他的方法的隔离级别设置为默认--&gt;            &lt;tx:method name="*" isolation="DEFAULT"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--3. 配置AOP增强--&gt;    &lt;!--将上面的事务通知引用进来，并且设置aop增强的切入点，即该包下的所有方法都进行增强    第一个*号表示返回值任意，后面表示iml包下的，所有后缀为ServiceImpl的类的，所有有任意参数的方法都进行aop增强--&gt;    &lt;!--接下来就可以到index.jsp中写一个表单，来测试是否能添加保存数据了--&gt;    &lt;aop:config&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* guang.fram.service.impl.*ServiceImpl.*(..))"/&gt;    &lt;/aop:config&gt;</code></pre><p>配置好之后，则需要从页面中提交数据，然后看是否能保存到数据库中，其具体的执行过程是，调用cotroller中的save方法，而它里面调用了AccountServiceImpl的save方法，这个save方法里面又有AccountDao的代理对象，它可以调用dao的save方法，即将数据保存到数据库中。<br>要从页面提交数据，则需要在index.jsp中先写一个表单，index.jsp修改后如下：</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: guang  Date: 2020/4/21  Time: 16:32  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;%--先delete掉原来的index.jsp文件，然后new一个--%&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--href后的account为一级目录，findAll为标签定义好此标签后，然后到controller包下的AccountController方法中定义findAll方法--%&gt;&lt;a href="account/findAll"&gt;测试测试测试测试查询数据的数据&lt;/a&gt;&lt;%--测试保存数据，action表示请求路径，要在AccountController中提供相应的访问路径和方法--%&gt;&lt;form action="account/save" method="post"&gt;    姓名 &lt;input type="text" name="name"/&gt; &lt;br/&gt;    金额 &lt;input type="text" name="money"/&gt; &lt;br/&gt;    &lt;input type="submit" value="保存"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> action=”account/save” 是请求路径，这个是放在AccountController里的注解，如下：</p><pre><code>package guang.fram.controller;import guang.fram.domain.Account;import guang.fram.service.AccountService;//import jdk.packager.internal.Module;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping("/account")public class AccountController {    /*在web.xml中配置好监听器之后，就整合好了spring与springmvc，就可以在这个类中使用依赖注入了*/    @Autowired    private AccountService accountService;    @RequestMapping("/findAll")    public String findAll(Model model){        System.out.println("表现层在查询所有的账户信息");        //下面这个是使用了spring的依赖注入后生成的对象所调用的service里面的方法        List&lt;Account&gt; list = accountService.findAll();        //然后在上面的findAll的参数表里边用一个Moudel对象，将数据存入一个键值对里边        model.addAttribute("list",list);        return "list";    }    //页面提交的数据保存到数据库的功能    @RequestMapping("/save")    //从页面提交拿到的数据，要先封装，可以直接在参数列表中定义一个Account对象，会自动将传入的参数封装到此对象中    //然后直接使用spring管理的对象accountService直接调用save方法就可以了    public String save(Account account){        accountService.saveAccount(account);        return "list";    }}</code></pre><p>至此，所有的整合完毕，再次启动服务器进行测试，启动后，页面如下，并填入数据：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/96ab09dc2ebcc4088c3e531590bf7c20.png" alt="image.png"></p><p>点击”保存”后，查看数据库是是否数据插入成功：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/53041c31fb52c25e9fc3f5eb96f2fb81.png" alt="image.png"></p><p>但是”保存”之后直接跳转list页面的，而此时的list页面因为没有经过findAll方法，所以显示的还是如下内容：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/f2a3fbd7186b5f093071cb0de4f96b63.png" alt="image.png"></p><p>如果想要保存后，跳转的页面显示数据库中所有的数据，则可以使用转发，由save转发到findAll这个servlet。代码如下：</p><pre><code> /* * 或者可以保存数据后，不直接跳到list页面，而是使用重定向到findAll方法，将数据库的数据再显示出来，代码如下 * */public String save(Account account, HttpServletRequest request, HttpServletResponse response) throws Exception {     accountService.save(account);     //重定向到findAll那个servlet去，这样跳转的list页面里就会把数据库的数据也显示出来了     response.sendRedirect(request.getContextPath()+"/account/findAll");     return "list"; }</code></pre><p>使用这个save方法，点击”保存”后，跳转的页面是这样的</p><p><img src="https://pic.rmb.bdstatic.com/bjh/ca3ef6f2d1552194f7c915da4ceaf174.png" alt="image.png"></p><p>至此，所有的整合完毕，ssm框架已经搭建好了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 中的中文乱码问题</title>
      <link href="/2020/05/21/springmvc-zhong-de-zhong-wen-luan-ma-wen-ti/"/>
      <url>/2020/05/21/springmvc-zhong-de-zhong-wen-luan-ma-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-中的中文乱码问题"><a href="#SpringMVC-中的中文乱码问题" class="headerlink" title="SpringMVC 中的中文乱码问题"></a>SpringMVC 中的中文乱码问题</h1><p>在前段时间玩的一个SSM项目中，遇到了不少中文乱码的问题，经常读出的数据变成了“？？？”，我也是一脸 ？？？，现在做个小记录。</p><p>其实除了在SpringMVC中有中文乱码的问题，在MyBatis中同样存在，一般是编码方式不统一导致的，大部分可以通过配置文件去解决，至于不能解决的那部分，只是我还没碰到罢了。</p><h3 id="分门别类："><a href="#分门别类：" class="headerlink" title="分门别类："></a>分门别类：</h3><h4 id="1-要在web-xm中配置拦截器"><a href="#1-要在web-xm中配置拦截器" class="headerlink" title="1. 要在web.xm中配置拦截器"></a>1. 要在web.xm中配置拦截器</h4><p>注意web.xml的配置要遵守一定的顺叙,一个样例如下：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</code></pre><p> 配置路径，以使得监听器能去加载spring的配置文件applicationContext,配置好之后，就能在**tController类中使用依赖注入了</p><pre><code>  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--解决中文乱码的问题，设置过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;!--设定编码集--&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;!--设置该字符过滤器要拦截的内容--&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;!--表示所有的内容都被此过滤器拦截--&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><p> 配置监听器，因为启动服务器后，加载web.xml文件，根据此文件加载springMVC的配置文件，而没有去加载spring的配置文件，<br>  所以需要设置此监听器，当服务器启动开始加载servletContext对象时，也去加载spring的配置文件<br> 但该监听器 默认只加载WEB-INF目录下的applicationContext.xml配置文件，所以下面还需要配置其路径</p><pre><code>&lt;listener&gt;  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;  &lt;!--这里是配置前端控制器--&gt;  &lt;!--希望做的是 1.加载springMVC.xml配置文件  &lt;                1. 启动服务器，就创建该servlet--&gt; &lt;servlet&gt;   &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;   &lt;!--加载springMVC配置文件，springMVC.xml配置文件在resources目录下进行创建，   创建的方法是：右键resources-&gt;new-&gt;选择xml configuration File-&gt;选择Spring config-&gt;命名为springMVC.xml--&gt;   &lt;init-param&gt;     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;     &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;   &lt;/init-param&gt;   &lt;!--启动服务器，创建该servlet--&gt;   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;dispatchServlet&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="2-数据库的编码方式"><a href="#2-数据库的编码方式" class="headerlink" title="2. 数据库的编码方式"></a>2. 数据库的编码方式</h4><p>(一)：数据库端字符集设置</p><p>　　1. 安装mysql时，会有一个数据库编码设置，将其设置为utf-8</p><p>　　2. 先设置数据库的字符集属性；</p><p>　　3. 将要显示中文的字段设置为UTF-8</p><p>springMVC项目，存中文到mysql是乱码（?????）<br>问题：jdbc连接mysql数据库，web页面输入的中文，存到数据库却变成”？？？？”；</p><p>　　但是数据库中的中文却能够正常读出并在页面显示<br>mysql中运行 ：SHOW VARIABLES LIKE ‘char%’</p><p>发现唯一一个不是utf8的是character_set_server这个参数。</p><p>在my.cnf中，mysqld下添加“character-set-server=utf8”</p><p>重启mysql后，问题解决。</p><h4 id="3-检查Spring的配置文件"><a href="#3-检查Spring的配置文件" class="headerlink" title="3. 检查Spring的配置文件"></a>3. 检查Spring的配置文件</h4><p>如果web.xml和数据库的编码格式都设置为了utf8，仍存到数据库之后为乱码<br>则有可能是传输的时候出现了问题，所以继续检查spring的配置文件applicationContext.xml中，配置连接池时，url配置是否加上了编码方式，如下：</p><p>这时spring配置中整合spring与mybatis的其中一段配置，这是配置连接池的，在url后面指定传输时的数据编码格式为utf8</p><pre><code> &lt;!--配置连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;!--配置四个属性--&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm?characterEncoding=utf8"/&gt;    &lt;property name="user" value="root"/&gt;    &lt;property name="password" value=""/&gt;&lt;/bean&gt;</code></pre><h4 id="4-补充：Mybatis-中的中文乱码"><a href="#4-补充：Mybatis-中的中文乱码" class="headerlink" title="4. 补充：Mybatis 中的中文乱码"></a>4. 补充：Mybatis 中的中文乱码</h4><p>mybatis操作数据的乱码有两种，一是数据库本身插入中文就显示乱码，这个可以通过修改库或者表的编码格式进行修改或者在建表的时候就选择utf8的编码格式。</p><p>第二种是mybatis传入中文数据到数据库，建库时设置了数据库默认字符集为UTF-8，通过mysql workbench直接插入中文显示完全正常。但是使用mybaits插入数据时，中文显示成了”???”这样的乱码。但从数据库获取的中文不会乱码。跟踪数据库操作，SQL语句中的中文还是显示正常的，但是插入到mysql数据库后就乱码了，于是判断可能是数据库连接的问题。后来在网上找了下资料，发现确实可以为mysql数据库的连接字符串设置编码方式，如下：</p><pre><code>jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始话</title>
      <link href="/2020/05/17/chu-shi-hua/"/>
      <url>/2020/05/17/chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>abulading，阿不拉丁，没有神灯。<br>很喜欢一个故事。雪夜里月色晴朗，王徽之忽然想起自己的老朋友，便想去朋友家探望，连夜乘船跑了老远，终于到了门口。但到了不见朋友反而准备转身回去，众人不解，他道：”本乘兴而行，兴尽而反，何必见安道耶”<br>做好这个小空间的时候，其实也是一时兴起，并不有宏远的打算，大抵做很多事情时都是这样，随遇而安一些。但还是会有些零碎的想法，先整点笔记，或许以后能成系统。也不排除一些奇思妙想，或嬉笑怒骂，或柴米油盐，或游山玩水，或厨房与爱，或阴阳异术……<br>想到什么就什么吧，我又懂什么呢</p><p>“you know nothing”—- Ygritte</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
